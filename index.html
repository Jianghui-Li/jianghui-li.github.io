<!DOCTYPE html>
<html lang="en">
<link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css" rel="stylesheet">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Jianghui Li's Personal Website</title>
    <style>
        @media (min-width: 768px) {
            .section {
                margin: 20px 330px;
                min-width: 540px;
            }

            .about-container {
                flex-direction: row;
                text-align: left;
                min-width: 540px;
            }

            .research-container {
                flex-direction: row;
                text-align: left;
                min-width: 540px;
            }

            #top-menu {
                left: 200px;
                right: 200px;
                border-radius: 0 0 10px 10px;
            }

            #top-menu .nav-link {
                font-size: 24px;
            }
        }

        @media (max-width: 767px) {
            .photo-frame {
                width: 120px;
                height: 160px;
            }

            .research-project {
                margin: 10px 0;
            }

            .section h3 {
                font-size: 20px;
            }

            .section p {
                font-size: 14px;
            }

            #about {
                margin-top: 100px;
            }

            .fish-toggle {
                margin-left: 10px;
            }

            #fishToggle {
                height: 35px;
            }
        }
        body {
            min-width: 1500px;
            margin: 0;
            padding: 0;
            font-family: Arial, sans-serif;
            background-color: black;
            overflow-y: scroll;
            overflow-x: auto;
        }

        canvas {
            position: fixed;
            top: 60px;
            left: 0;
            width: 100%;
            height: calc(100% - 60px);
            z-index: -1;
            pointer-events: none;
        }

        #top-menu {
            position: fixed;
            top: 0;
            left: 200px;
            right: 200px;
            height: 60px;
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            display: flex;
            align-items: center;
            padding: 0 20px;
            z-index: 1000;
            border-radius: 0 0 0 0;
        }

        #top-menu h1 {
            margin: 0;
            font-size: 24px;
            margin-right: 0px;
        }

        #top-menu .nav-link {
            color: #ffc500;
            text-decoration: none;
            margin: 0 15px;
            font-size: 24px;
            position: relative;
            display: inline-block;
        }

        #top-menu .nav-link::after {
            content: ''; /* Placeholder for the underline */
            position: absolute;
            left: 0;
            bottom: -5px; /* Position the underline just below the text */
            width: 0%; /* Start with no underline */
            height: 2px; /* Thickness of the underline */
            background: linear-gradient(90deg, #ffc500, #ff8000, #1eceff); /* Gradient for underline */
            transition: width 1s ease; /* Smoothly expand the underline */
        }

        #top-menu .nav-link:hover {
            color: transparent; /* Hide the default text color */
            background: linear-gradient(90deg, #ffc500, #ff8000, #1eceff); /* Gradient colors */
            background-clip: text; /* Clip gradient to text */
            -webkit-background-clip: text; /* For Safari compatibility */
            transition: background 1s ease; /* Smooth transition for text */
        }

        #top-menu .nav-link:hover::after {
            width: 100%;
        }
        #controls-panel {
            position: fixed;
            top: 60px;
            left: -270px;
            height: calc(100% - 60px);
            width: 170px;
            background-color: rgba(0, 0, 0, 0.5);
            color: white;
            padding: 20px;
            box-shadow: 2px 0 5px rgba(0, 0, 0, 0.5);
            overflow-y: auto;
            transition: left 0.3s ease;
            z-index: 100;
        }

        #controls-panel.active {
            left: 0;
        }

        #toggle-controls {
            position: fixed;
            top: 80px;
            left: 0px;
            background-color: rgba(255, 255, 255, 0.1);
            color: white;
            border: none;
            border-radius: 8px;
            padding: 10px;
            font-size: 16px;
            cursor: pointer;
            z-index: 101;
            transition: left 0.3s ease;
        }

        #controls-panel.active + #toggle-controls {
            left: 190px;
        }

        #toggle-controls::after {
            font-family: "Font Awesome 5 Free";
            content: "\f061";
            font-weight: 900;
            font-size: 18px;
        }

        #toggle-controls.active::after {
            content: "\f060";
        }

        html {
            scroll-behavior: smooth;
        }

        h1 {
            margin: 0px;
            font-size: 20px;
        }

        h3 {
            margin: 0px;
            font-size: 16px;
        }

        .header-title {
            text-align: center;
            color: white;
            margin: 80px 20px 40px 20px;
            text-shadow: 2px 2px 5px rgba(0, 0, 0, 0.8);
        }

        .section {
            margin: 20px 330px 20px 330px;
            color: white;
            text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.8);
            z-index: 1;
            position: relative;
        }
        #click-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0;  /* Between canvas and content */
            pointer-events: auto;  /* Catch all clicks */
        }
        .section h3 {
            font-size: 24px;
            margin-bottom: 20px;
            color: #ffc500;
        }
        .section h4 {
            font-size: 16px;
            margin-bottom: 20px;
            color: #ffc500;
        }

        .section p, .section ul {
            font-size: 16px;
            line-height: 1.8;
        }

        .nav-link {
            color: #ffc500;
            text-decoration: none;
            display: block;
            margin: 10px 0;
            font-size: 16px;
        }

        .nav-link:hover {
            text-decoration: underline;
        }

        .control-button {
            background-color: rgba(255, 255, 255, 0.1);
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            transition: background-color 0.2s;
            width: 100%;
            margin-bottom: 10px;
        }

        .control-button:hover {
            background-color: rgba(255, 255, 255, 0.2);
        }

        select {
            width: 100%;
            padding: 6px;
            margin: 5px 0;
            background: black;
            color: white;
            border: none;
            border-radius: 8px;
        }
        .section {
            opacity: 1;
            visibility: visible;
            transition: opacity 0.5s ease, visibility 0.5s ease;
        }

        .hidden-content {
            opacity: 0;
            pointer-events: none;
        }
        #about {
            margin-top: 200px;
            padding-top: 0px;
            position: relative;
        }
        .about-container {
            display: flex;
            align-items: center;
            gap: 20px;
        }

        .photo-frame {
            width: 150px;
            height: 200px;
            border: 5px solid #ffc500;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }

        .photo-frame img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .about-content {
            flex: 1; /* Allow the text to take up the remaining space */
        }
        .research-project {
            margin-top: 20px; /* Add spacing between projects */
            padding: 10px 15px;
            background-color: rgba(0, 0, 0, 0.6); /* Semi-transparent background */
            border-left: 4px solid #ffc500; /* Highlight each project */
            border-radius: 5px; /* Rounded corners */
        }
        .research-project h4 {
            margin-bottom: 10px;
            color: #ffc500;
        }
        .research-project p {
            margin: 0;
            line-height: 1.6;
        }
        .photo-frame-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }

        .photo-frame {
            width: 150px;
            height: 200px;
            border: 2px solid #ffc500; /* Gold border for the frame */
            border-radius: 5px; /* Rounded corners */
            overflow: hidden; /* Ensures the photo stays inside the frame */
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2); /* Optional: Add a shadow for depth */
        }

        .photo-frame img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        .research-container {
            display: flex;
            align-items: center;
            gap: 20px;
            margin-top: 10px;
            margin-bottom: 10px;
        }

        .research-photo {
            width: 150px;
            height: 150px;
            flex-shrink: 0;
            overflow: hidden;
            border-radius: 2px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }

        .research-photo img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .research-text {
            flex: 1;
        }

        .research-text h4 {
            color: #ffc500;
            margin-bottom: 10px;
        }

        .research-text p {
            line-height: 1.6;
        }

        .contact-icons {
            display: flex;
            justify-content: center;
            gap: 15px;
        }

        .contact-icons a {
            color: #ffc500;
            font-size: 20px;
            text-decoration: none;
            transition: color 0.3s ease, transform 0.3s ease;
        }

        .contact-icons a:hover {
            color: #1eceff;
            transform: scale(1.2);
        }
        .fish-toggle {
            margin-left: auto;
            display: flex;
            align-items: center;
            padding-right: 20px;
            padding-top: 5px;
        }

        #fishToggle {
            height: 45px;
            width: auto;
            cursor: pointer;
            transition: transform 0.3s ease;
        }

        #fishToggle:hover {
            transform: scale(1.2);
        }
        a {
            color: #1eceff;
            text-decoration: none;
        }

        a:hover {
            text-decoration: underline;
        }
        @media screen and (max-width: 767px) {
            #top-menu {
                left: 0;
                right: 0;
                border-radius: 0;
                justify-content: space-around;
                padding: 0 10px;
            }

            #top-menu .nav-link {
                font-size: 16px;
                margin: 0 8px;
            }

            .fish-toggle {
                margin-left: 10px;
                padding-right: 10px;
            }

            #fishToggle {
                height: 35px;
            }

            .section {
                margin-left: 20px;
                margin-right: 20px;
            }

            #about {
                margin-top: 100px;
            }

            canvas {
                top: 60px;
            }

            .header-title {
                font-size: 16px;
            }

            .section h3 {
                font-size: 12px;
                margin-bottom: 10px;
            }

            .section h4 {
                font-size: 10px;
                margin-bottom: 10px;
            }

            .section p, 
            .section ul {
                font-size: 10px;
                line-height: 1.6;
            }

            .about-content p {
                font-size: 10px;
                line-height: 1.6;
            }

            .research-text h4 {
                font-size: 12px;
            }

            .research-text p {
                font-size: 10px;
                line-height: 1.6;
            }

            .contact-icons a {
                font-size: 12px;
            }

            .research-photo {
                width: 120px;
                height: 120px;
            }

            #controls-panel h3 {
                font-size: 16px;
            }

            #controls-panel p {
                font-size: 12px;
            }

            .control-button {
                font-size: 12px;
                padding: 6px 10px;
            }

            select {
                font-size: 12px;
                padding: 4px;
            }

            #fishCount {
                font-size: 12px;
            }
        }
    </style>
</head>

<body>
    <div id="top-menu">
        <a class="nav-link" href="javascript:void(0)" onclick="scrollToSection('about')">About</a>
        <a class="nav-link" href="javascript:void(0)" onclick="scrollToSection('research')">Research</a>
        <a class="nav-link" href="javascript:void(0)" onclick="scrollToSection('contact')">Contact Info</a>
        <div class="fish-toggle">
            <img src="images/fishon.png" alt="Toggle Fish" id="fishToggle" title="Turn on fish tank" onclick="toggleFish()" />
        </div>
    </div>
    <div id="controls-panel">
        <h3>Fish Tank Controls</h3>
        <button class="control-button" onclick="toggleDayNight()">ðŸŒ™/ðŸŒž Mode</button>
        <select id="fishSelector">
            <option value="minnow">Minnow</option>
            <option value="bluegill">Bluegill</option>
            <option value="crappie">Crappie</option>
            <option value="perch">Perch</option>
            <option value="guppy">Guppy</option>
            <option value="tetra">Tetra</option>
            <option value="zebra">Zebrafish</option>
            <option value="goldfish">Goldfish</option>
            <option value="herring">Herring</option>
            <option value="trout">Brown Trout</option>
            <option value="salmon">Salmon</option>
            <option value="salmon2">White Salmon</option>
            <option value="walleye">Walleye</option>
            <option value="spotted">Spotted Bass</option>
            <option value="smallmouth">Smallmouth Bass</option>
            <option value="largemouth">Largemouth Bass</option>
            <option value="pike">Northern Pike</option>
            <option value="crucian">Crucian Carp</option>
            <option value="carp">Common Carp</option>
            <option value="ghost">Ghost Carp</option>
            <option value="carp2">Leather Carp</option>
            <option value="koi">Koi Carp</option>
            <option value="bullhead">Bullhead Catfish</option>
            <option value="channel">Channel Catfish</option>
            <option value="flathead">Flathead Catfish</option>
            <option value="catfish">Blue Catfish</option>
            <option value="sturgeon">Lake Sturgeon</option>
            <option value="beluga">Beluga</option>
        </select>
        <button class="control-button" onclick="addSelectedFish()">Add Fish</button>
        <button class="control-button" onclick="toggleAutoFeed()">Disable Auto Feed</button>
        <button class="control-button" onclick="dropFood()">Feed Pellets</button>
        <button class="control-button" onclick="clearFishTank()">Clear Tank</button>
        <button class="control-button" onclick="toggleAnimation()">Pause/Play</button>
        <button class="control-button" onclick="togglePageContent()">Hide Home Page Content</button>
        <h3>Fish Count</h3>
        <p id="fishCount">Total Fish: 0</p> <!-- Fish count display -->
    </div>

    <button id="toggle-controls"></button>

    <h1 class="header-title"></h1>

    <section id="about" class="section">
        <div class="about-container">
            <div class="photo-frame-container">
                <div class="photo-frame">
                    <img src="images/jianghui-li.jpg" alt="My Photo">
                </div>
                <div class="contact-icons">
                    <a href="mailto:jli159@syr.edu" target="_blank" title="Email">
                        <i class="fas fa-envelope"></i>
                    </a>
                    <a href="https://github.com/Jianghui-Li" target="_blank" title="GitHub">
                        <i class="fab fa-github"></i>
                    </a>
                    <a href="https://www.linkedin.com/in/jianghui-li-9804/" target="_blank" title="LinkedIn">
                        <i class="fab fa-linkedin"></i>
                    </a>
                    <a href="files/jianghui-li-cv.pdf" target="_blank" title="View CV">
                        <i class="fas fa-file-alt"></i>
                    </a>
                </div>
            </div>
            <div class="about-content">
                <h3>About me</h3>
                <p>HelloðŸ‘‹! My name is Jianghui Li, and I am a Master's student at the iSchool of Syracuse University. I am interested in researching how interactions within sociotechnical systems such as collaborative platforms and social media shape individual and collective decision-making, behaviors, and responses to various challenges. 
                    I use computational methods such as machine learning, natural language processing, and inferential statistics, alongside qualitative methods, drawing on insights from ecology and complex adaptive systems to guide my research. 
                    </p>
            </div>
        </div>
    </section>
    

    <section id="research" class="section">
        <h3>Research</h3>
        <div class="research-project">
            <div class="research-container">
                <div class="research-photo">
                    <img src="images/r-att.png" alt="Belief Dynamics Research" />
                </div>
                <div class="research-text">
                    <h4>Predicting Belief Dynamics</h4>
                    <p>
                        This project focuses on predicting individual belief stability across various discourses including climate change, cross-cultural, political, and AI on social media platforms. While existing 
                        works focus on modeling and analyzing population-level belief shifts, this work includes individual stability by building on <a href="https://ojs.aaai.org/index.php/ICWSM/article/view/22154/21933" target="_blank">the belief landscape model</a> with new computational methods.
                        The on-going work is presented at the ACM Collective Intelligence (CIâ€™24) and 10th International Conference on Computational Social Science (IC2S2). 
                        <a href="files/CI24_paper.pdf" target="_blank">The extended abstract</a> and <a href="files/ic2s2-poster-jianghui-li.pdf" target="_blank">the poster</a> are available. 
                    </p>
                </div>
            </div>
        </div>
        
        <div class="research-project">
            <div class="research-container">
                <div class="research-photo">
                    <img src="images/r-art.png" alt="AI Art Debate" />
                </div>
                <div class="research-text">
                    <h4>AI Art Debate</h4>
                    <p>
                        This research examines public debates around image-generative AI. This study uncovered potential themes for AI art 
                        debate in natural settings using data collected from Reddit. We also performed a longitudinal analysis on how these themes change over time. 
                        We found that themes tend to gain traction from external events aligned with each themeâ€™s focus, while internal factors within the discussion community, 
                        such as recurring arguments or influential posts, also play a significant role in driving engagement. Our work is accepted by the 58th Annual Hawaii International Conference on System Sciences (HICSS-58). 
                        <a href="files/HICSS25.pdf" target="_blank">The full paper is available</a>.
                    </p>
                </div>
            </div>
        </div>
    </section>
    

    <section id="contact" class="section">
        <h3>Contact Info</h3>
        <p>If you'd like to collaborate or learn more, feel free to reach out:</p>
        <ul style="list-style: none; padding: 0;">
            <li>
                <a href="mailto:jli159@syr.edu" target="_blank" style="color: #ffc500; text-decoration: none;">
                    <i class="fas fa-envelope"></i> jli159@syr.edu
                </a>
            </li>
            <li>
                <a href="https://github.com/Jianghui-Li" target="_blank" style="color: #ffc500; text-decoration: none;">
                    <i class="fab fa-github"></i> GitHub: github.com/Jianghui-Li
                </a>
            </li>
            <li>
                <a href="https://www.linkedin.com/in/jianghui-li-9804/" target="_blank" style="color: #ffc500; text-decoration: none;">
                    <i class="fab fa-linkedin"></i> LinkedIn: linkedin.com/in/jianghui-li-9804/
                </a>
            </li>
        </ul>
    </section>
    
    <canvas id="background"></canvas>
    <div id="click-overlay"></div>

    <script>
        const canvas = document.getElementById("background");
        const ctx = canvas.getContext("2d");
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        function scrollToSection(sectionId) {
            const section = document.getElementById(sectionId);
            if (section) {
                const topMenuHeight = document.getElementById('top-menu').offsetHeight;
                const extraSpacing = 50;
                const sectionTop = section.offsetTop - topMenuHeight - extraSpacing;

                window.scrollTo({
                    top: sectionTop,
                    behavior: 'smooth',
                });
            }
        }

        function togglePageContent() {
            const pageContent = document.querySelectorAll('.section, #top-menu');
            const isHidden = document.querySelector('.section').classList.contains('hidden-content');
            
            pageContent.forEach((element) => {
                element.classList.toggle('hidden-content');
            });
            const toggleButton = document.querySelector('.control-button[onclick="togglePageContent()"]');
            toggleButton.textContent = isHidden ? "Hide Home Page Content" : "Show Home Page Content";
        }

        const toggleButton = document.getElementById('toggle-controls');
        const controlsPanel = document.getElementById('controls-panel');
        toggleButton.addEventListener('click', () => {
            controlsPanel.classList.toggle('active');
            toggleButton.classList.toggle('active');
        });

        const overlay = document.getElementById('click-overlay');

        overlay.addEventListener('click', (event) => {
            const rect = canvas.getBoundingClientRect();
            spookCenter = {
                x: event.clientX - rect.left,
                y: event.clientY - rect.top
            };
            spookStartTime = Date.now();
        });

        function initializeFish() {
            if (fishActive) {
                clearFishTank(); // Clear existing fish first
            }
            
            // Reset all animation and speed related variables
            globalSpeedMultiplier = 1;
            animationActive = true;
            fishActive = true;
            
            const useAlternative = Math.random() < 0.5;
            const initialFishCounts = useAlternative
                ? {
                    perch: 22,
                    bluegill: 18,
                    crappie: 18,
                    largemouth: 2,
                    smallmouth: 2,
                    walleye: 2,
                    pike: 2,
                    bullhead: 6
                }
                : {
                    guppy: 15,
                    tetra: 20,
                    zebra: 15,
                    goldfish: 12,
                    koi: 4,
                    ghost: 6
                };

            for (const [type, count] of Object.entries(initialFishCounts)) {
                for (let i = 0; i < count; i++) {
                    fishArray.push(new Fish(type, true));
                }
            }
            
            updateFishCount();
            
            // Start animation only if fish are active
            if (fishActive) {
                animate();
            }
        }
        let fishActive = false;
        let animationFrameId = null;
        function toggleFish() {
            const toggleImg = document.getElementById('fishToggle');
            
            if (!fishActive) {
                // Turn fish on
                fishActive = true;
                animationActive = true;
                initializeFish();
                toggleImg.src = 'images/fishoff.png';
                toggleImg.title = "Turn off fish tank";
                
                // Update pause/play button state
                const toggleButton = document.querySelector('.control-button[onclick="toggleAnimation()"]');
                if (toggleButton) {
                    toggleButton.textContent = "Currently Playing";
                }
                
                // Enable auto-feed when adding fish
                autoFeedEnabled = true;
                const toggleFeedButton = document.querySelector('.control-button[onclick="toggleAutoFeed()"]');
                if (toggleFeedButton) {
                    toggleFeedButton.textContent = "Disable Auto Feed";
                }
                scheduleRandomFoodDrop(); // Start auto-feeding
            } else {
                // Turn fish off
                clearFishTank();
                toggleImg.src = 'images/fishon.png';
                toggleImg.title = "Turn on fish tank";
                
                // Disable auto-feed when clearing fish
                autoFeedEnabled = false;
                const toggleFeedButton = document.querySelector('.control-button[onclick="toggleAutoFeed()"]');
                if (toggleFeedButton) {
                    toggleFeedButton.textContent = "Enable Auto Feed";
                }
                clearTimeout(autoFeedTimeout); // Clear any pending auto-feed
            }
        }
        const fishSpecies = {
            sturgeon: { minSize: 90, maxSize: 220, defaultAngle: -Math.PI / 2, depthPreference: 'bottom', bottomBias: 0.8 },
            beluga: { minSize: 120, maxSize: 280, defaultAngle: -Math.PI / 2, depthPreference: 'bottom', bottomBias: 0.8 },
            pike: { minSize: 50, maxSize: 120, defaultAngle: -Math.PI / 2, depthPreference: 'top', depthBias: 0.6 },
            largemouth: { minSize: 35, maxSize: 80, defaultAngle: -Math.PI / 2},
            smallmouth: { minSize: 35, maxSize: 70, defaultAngle: -Math.PI / 2},
            spotted: { minSize: 35, maxSize: 65, defaultAngle: -Math.PI / 2},
            carp: { minSize: 45, maxSize: 110, defaultAngle: -Math.PI / 2},
            ghost: { minSize: 40, maxSize: 110, defaultAngle: -Math.PI / 2, variants: ['ghost', 'ghost-1', 'ghost-2', 'ghost-3']},
            carp2: { minSize: 50, maxSize: 130, defaultAngle: -Math.PI / 2},
            koi: { minSize: 40, maxSize: 110, defaultAngle: -Math.PI / 2, variants: ['koi', 'koi-1', 'koi-2', 'koi-3'] },
            crucian: { minSize: 20, maxSize: 40, defaultAngle: -Math.PI / 2},
            catfish: { minSize: 65, maxSize: 160, defaultAngle: -Math.PI / 2, depthPreference: 'bottom', bottomBias: 0.9 },
            flathead: { minSize: 60, maxSize: 140, defaultAngle: -Math.PI / 2, depthPreference: 'bottom', bottomBias: 0.9 },
            channel: { minSize: 40, maxSize: 100, defaultAngle: -Math.PI / 2, depthPreference: 'bottom', bottomBias: 0.9 },
            bullhead: { minSize: 20, maxSize: 50, defaultAngle: -Math.PI / 2, depthPreference: 'bottom', bottomBias: 0.9 },
            trout: { minSize: 35, maxSize: 80, defaultAngle: -Math.PI / 2, depthPreference: 'top', depthBias: 0.7 },
            salmon: { minSize: 60, maxSize: 130, defaultAngle: -Math.PI / 2, depthPreference: 'top', depthBias: 0.7 },
            salmon2: { minSize: 50, maxSize: 110, defaultAngle: -Math.PI / 2, depthPreference: 'top', depthBias: 0.7 },
            herring: { minSize: 12, maxSize: 30, defaultAngle: -Math.PI / 2, depthPreference: 'top', depthBias: 0.7 },
            walleye: { minSize: 40, maxSize: 80, defaultAngle: -Math.PI / 2},
            crappie: { minSize: 20, maxSize: 40, defaultAngle: -Math.PI / 2},
            bluegill: { minSize: 12, maxSize: 30, defaultAngle: -Math.PI / 2},
            perch: { minSize: 15, maxSize: 35, defaultAngle: -Math.PI / 2},
            goldfish: { minSize: 15, maxSize: 35, defaultAngle: -Math.PI / 2, variants: ['goldfish', 'goldfish-1', 'goldfish-2', 'goldfish-3']},
            guppy: { minSize: 6, maxSize: 18, defaultAngle: -Math.PI / 2},
            tetra: { minSize: 8, maxSize: 20, defaultAngle: -Math.PI / 2},
            zebra: { minSize: 6, maxSize: 18, defaultAngle: -Math.PI / 2},
            minnow: { minSize: 10, maxSize: 25, defaultAngle: -Math.PI / 2}
        };
        function updateFishCount() {
            const fishCountElement = document.getElementById('fishCount');
            fishCountElement.textContent = `Total Fish: ${fishArray.length}`;
            
            // Control auto-feed based on fish count
            if (fishArray.length === 0) {
                // Disable auto-feed if no fish
                const toggleButton = document.querySelector('.control-button[onclick="toggleAutoFeed()"]');
                if (toggleButton && autoFeedEnabled) {
                    autoFeedEnabled = false;
                    toggleButton.textContent = "Enable Auto Feed";
                    clearTimeout(autoFeedTimeout);  // Clear any pending auto-feed
                }
            }
        }
        function addSelectedFish() {
            if (!fishActive) {
                fishActive = true;
                animationActive = true;
                const toggleImg = document.getElementById('fishToggle');
                if (toggleImg) {
                    toggleImg.src = 'images/fishoff.png';
                }
                
                // Update pause/play button state
                const toggleButton = document.querySelector('.control-button[onclick="toggleAnimation()"]');
                if (toggleButton) {
                    toggleButton.textContent = "Currently Playing";
                }
                
                animate(); // Restart animation
            }

            const selector = document.getElementById('fishSelector');
            const type = selector.value;
            const newFish = new Fish(type);
            newFish.y = -newFish.size; // Start from top
            fishArray.push(newFish);
            updateFishCount();
        }

        const fishLifeSpans = {
            beluga: { min: 540000, max: 900000 },
            sturgeon: { min: 480000, max: 780000 },
            pike: { min: 240000, max: 480000 },
            largemouth: { min: 240000, max: 420000 },
            smallmouth: { min: 240000, max: 420000 },
            spotted: { min: 240000, max: 420000 },
            carp: { min: 300000, max: 480000 },
            ghost: { min: 300000, max: 480000 },
            carp2: { min: 300000, max: 480000 },
            koi: { min: 300000, max: 540000 },
            crucian: { min: 240000, max: 420000 },
            catfish: { min: 300000, max: 480000 },
            flathead: { min: 300000, max: 480000 },
            channel: { min: 300000, max: 480000 },
            bullhead: { min: 240000, max: 420000 },
            trout: { min: 240000, max: 420000 },
            salmon: { min: 240000, max: 420000 },
            salmon2: { min: 240000, max: 420000 },
            herring: { min: 240000, max: 360000 },
            walleye: { min: 240000, max: 420000 },
            crappie: { min: 200000, max: 360000 },
            bluegill: { min: 200000, max: 360000 },
            perch: { min: 200000, max: 360000 },
            goldfish: { min: 180000, max: 420000 },
            guppy: { min: 150000, max: 280000 },
            tetra: { min: 180000, max: 360000 },
            zebra: { min: 160000, max: 320000 },
            minnow: { min: 150000, max: 300000 }
        };
        class FoodPellet {
            constructor(x) {
                this.x = x || Math.random() * canvas.width;
                this.y = 0;
                this.size = 1;
                this.speed = 0.5 + Math.random() * 0.5;
                this.consumed = false;

                const colors = ['#FFD700', '#00FF00', '#FF0000'];
                this.color = colors[Math.floor(Math.random() * colors.length)];
            }

            update() {
                if (!this.consumed) {
                    this.y += this.speed;
                    return this.y < canvas.height;
                }
                return false;
            }

            draw() {
                if (!this.consumed) {
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                    ctx.fillStyle = this.color;
                    ctx.fill();
                }
            }
        }

        const fishImages = {};
        let fishLoaded = 0;

        const foodPellets = [];

        function clearFishTank() {
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }

            while (fishArray.length > 0) {
                fishArray.pop();
            }
            while (foodPellets.length > 0) {
                foodPellets.pop();
            }

            fishActive = false;
            globalSpeedMultiplier = 1;
            
            // Draw the background without affecting surface lights
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            if (!isDarkMode) {
                let gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
                gradient.addColorStop(0, 'rgba(0, 75, 65, 0.9)');
                gradient.addColorStop(0.5, 'rgba(0, 45, 40, 0.95)');
                gradient.addColorStop(1, 'rgba(0, 25, 20, 0.98)');
                
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Continue animating existing surface lights
                function animateExistingSurfaceLights() {
                    if (!fishActive && !isDarkMode) {
                        ctx.clearRect(0, 0, canvas.width, canvas.height);
                        
                        // Redraw gradient background
                        ctx.fillStyle = gradient;
                        ctx.fillRect(0, 0, canvas.width, canvas.height);
                        
                        // Animate existing surface lights without reinitializing
                        surfaceLights.forEach(light => {
                            light.x += light.speed;
                            if (light.x > canvas.width + light.width) {
                                light.x = -light.width;
                            }

                            let beamGradient = ctx.createRadialGradient(
                                light.x, 0, 0,
                                light.x, 0, light.width
                            );
                            
                            beamGradient.addColorStop(0, `rgba(255, 250, 240, ${light.intensity * 0.2})`);
                            beamGradient.addColorStop(0.5, `rgba(240, 240, 230, ${light.intensity * 0.1})`);
                            beamGradient.addColorStop(1, 'rgba(255, 255, 255, 0)');

                            ctx.fillStyle = beamGradient;
                            
                            ctx.beginPath();
                            ctx.moveTo(light.x - light.width/2, 0);
                            ctx.lineTo(light.x + light.width/2, 0);
                            ctx.lineTo(light.x + light.width, canvas.height);
                            ctx.lineTo(light.x - light.width, canvas.height);
                            ctx.closePath();
                            ctx.fill();
                        });
                        
                        requestAnimationFrame(animateExistingSurfaceLights);
                    }
                }
                
                // Only start surface light animation if it's not already running
                if (!animationFrameId) {
                    animateExistingSurfaceLights();
                }
            } else {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }
            
            updateFishCount();
        }

        function addNewFish(type) {
            const newFish = new Fish(type, false);
            newFish.y = -newFish.size; // Start from top
            fishArray.push(newFish);
        }

        window.onload = function() {
            // Initialize with fish off
            const toggleImg = document.getElementById('fishToggle');
            toggleImg.src = 'images/fishon.png';
            fishActive = false;

            const useAlternative = Math.random() < 0.5;
            const initialFishCounts = useAlternative
                ? {
                    perch: 24,
                    bluegill: 20,
                    crappie: 12,
                    largemouth: 2,
                    smallmouth: 2,
                    walleye: 2,
                    pike: 2,
                    bullhead: 6
                }
                : {
                    guppy: 15,
                    tetra: 20,
                    zebra: 15,
                    goldfish: 12,
                    koi: 8,
                    ghost: 6
                };

            for (const [type, count] of Object.entries(initialFishCounts)) {
                for (let i = 0; i < count; i++) {
                    fishArray.push(new Fish(type, true));
                }
            }

            updateFishCount();
            animate();
        };
        function removeFish(fish) {
            const index = fishArray.indexOf(fish);
            if (index > -1) {
                fishArray.splice(index, 1);
                updateFishCount();
            }
        }
        function dropFood() {
            // If tank is inactive but we try to feed, reactivate it
            if (!fishActive) {
                fishActive = true;
                animationActive = true;
                const toggleImg = document.getElementById('fishToggle');
                if (toggleImg) {
                    toggleImg.src = 'images/fishoff.png';
                }
                animate(); // Restart animation
            }

            // Now proceed with food dropping
            const fishCount = fishArray.length;
            const pelletCount = Math.min(10 + Math.floor(fishCount / 2), 80);

            for (let i = 0; i < pelletCount; i++) {
                const mean = canvas.width / 2;
                const standardDeviation = canvas.width / 6;
                const x = generateGaussian(mean, standardDeviation);
                const boundedX = Math.max(0, Math.min(canvas.width - 50, x));
                foodPellets.push(new FoodPellet(boundedX));
            }

            console.log(`Dropped ${pelletCount} food pellets for ${fishCount} fish.`);
        }

        function generateGaussian(mean, standardDeviation) {
            let u1 = Math.random();
            let u2 = Math.random();
            let randStdNormal = Math.sqrt(-2.0 * Math.log(u1)) * Math.sin(2.0 * Math.PI * u2); // Random normal (0,1)
            return mean + standardDeviation * randStdNormal; // Adjusted for desired mean and standard deviation
        }
        function scheduleRandomFoodDrop() {
            if (!autoFeedEnabled) return;
            // Only schedule next drop if there are fish
            if (fishArray.length > 0) {
                const randomInterval = Math.floor(Math.random() * 20000) + 10000;
                autoFeedTimeout = setTimeout(() => {
                    if (fishArray.length > 0) {  // Double-check before dropping
                        dropFood();
                    }
                    scheduleRandomFoodDrop(); // Schedule next drop
                }, randomInterval);
            }
        }

        let autoFeedEnabled = true;

        function toggleAutoFeed() {
            if (!autoFeedEnabled && fishArray.length === 0) {
                console.log("Cannot enable auto-feed without fish");
                return;  // Prevent enabling auto-feed when no fish
            }

            autoFeedEnabled = !autoFeedEnabled;
            const toggleButton = document.querySelector('.control-button[onclick="toggleAutoFeed()"]');
            toggleButton.textContent = autoFeedEnabled ? "Disable Auto Feed" : "Enable Auto Feed";

            if (!autoFeedEnabled) {
                clearTimeout(autoFeedTimeout);
            } else {
                scheduleRandomFoodDrop();
            }
        }

        // Variable to store the timeout ID for scheduled food drops
        let autoFeedTimeout;

        function scheduleRandomFoodDrop() {
            if (!autoFeedEnabled) return; // Exit if autofeed is disabled

            const randomInterval = Math.floor(Math.random() * 20000) + 10000; // Random interval between 10-20 seconds
            autoFeedTimeout = setTimeout(() => {
                dropFood();
                scheduleRandomFoodDrop(); // Schedule the next drop
            }, randomInterval);
        }
        scheduleRandomFoodDrop();

        // Modify the image loading section to not auto-initialize
        const totalImagesToLoad = Object.keys(fishSpecies).length + 9;

        // Load regular fish images without auto-initialization
        Object.keys(fishSpecies).forEach(type => {
            if (type !== 'goldfish' && type !== 'koi'&& type !== 'ghost') {
                const img = new Image();
                img.src = `images/${type}.png`;
                img.onload = () => {
                    fishLoaded++;
                    console.log(`Loaded ${type}.png`);
                    fishImages[type] = img;
                    // Don't initialize on load completion
                };
                img.onerror = () => {
                    console.error(`Failed to load ${type}.png`);
                };
            }
        });

        ['goldfish', 'goldfish-1', 'goldfish-2', 'goldfish-3'].forEach(variant => {
            const img = new Image();
            img.src = `images/${variant}.png`;
            img.onload = () => {
                fishLoaded++;
                console.log(`Loaded ${variant}.png`);
                fishImages[variant] = img;
                // Don't initialize on load completion
            };
            img.onerror = () => {
                console.error(`Failed to load ${variant}.png`);
            };
        });

        ['koi', 'koi-1', 'koi-2', 'koi-3'].forEach(variant => {
            const img = new Image();
            img.src = `images/${variant}.png`;
            img.onload = () => {
                fishLoaded++;
                console.log(`Loaded ${variant}.png`);
                fishImages[variant] = img;
                // Don't initialize on load completion
            };
            img.onerror = () => {
                console.error(`Failed to load ${variant}.png`);
            };
        });
        ['ghost', 'ghost-1', 'ghost-2', 'ghost-3'].forEach(variant => {
            const img = new Image();
            img.src = `images/${variant}.png`;
            img.onload = () => {
                fishLoaded++;
                console.log(`Loaded ${variant}.png`);
                fishImages[variant] = img;
                // Don't initialize on load completion
            };
            img.onerror = () => {
                console.error(`Failed to load ${variant}.png`);
            };
        });

        // Add window load event to ensure proper initial state
        window.addEventListener('load', () => {
            const toggleImg = document.getElementById('fishToggle');
            if (toggleImg) {
                toggleImg.src = 'images/fishon.png';
            }
            fishActive = false;
            clearFishTank(); // Ensure clean initial state
        });

        const fishArray = [];
        let animationActive = true;
        let globalSpeedMultiplier = 1;

        function checkRandomDeaths() {
            const fishCount = fishArray.length;
            let deathChance = 0;

            if (fishCount > 400) {
                deathChance = 0.015;
            } else if (fishCount > 325) {
                deathChance = 0.008;
            } else if (fishCount > 250) {
                deathChance = 0.004;
            } else if (fishCount > 150) {
                deathChance = 0.002;
            }

            if (deathChance > 0) {
                fishArray.forEach((fish, index) => {
                    if (fish.isAlive) {
                        const effectiveDeathChance = fish.isAdult ? deathChance / 3 : deathChance;
                        if (Math.random() < effectiveDeathChance) {
                            fish.isAlive = false;
                            fish.causeOfDeath = 'random'; // Use "random" as cause of death
                            fish.rotationForDeath = 0; // Initialize rotation for death animation
                            fish.opacity = 1.0; // Reset opacity for fade-out animation
                        }
                    }
                });
                updateFishCount(); // Update the displayed count
            }
        }

        // Call checkRandomDeaths every second
        setInterval(checkRandomDeaths, 1000);

        const fishBehavior = {
            beluga: { isSchooling: false, isPredator: true, schoolSize: 0, preyTypes: [] },
            sturgeon: { isSchooling: false, isPredator: true, schoolSize: 0, preyTypes: [] },
            pike: { isSchooling: true, isPredator: true, schoolSize: 5, preyTypes: ['minnow', 'crappie','guppy','goldfish','tetra','perch','bluegill','zebra','crucian'] },
            largemouth: { isSchooling: true, isPredator: true, schoolSize: 5, preyTypes: ['minnow', 'crappie','guppy','goldfish','tetra','perch','bluegill','zebra','crucian'] },
            smallmouth: { isSchooling: true, isPredator: true, schoolSize: 5, preyTypes: ['minnow', 'crappie','guppy','goldfish','tetra','perch','bluegill','zebra','crucian'] },
            spotted: { isSchooling: true, isPredator: true, schoolSize: 5, preyTypes: ['minnow', 'crappie','guppy','goldfish','tetra','perch','bluegill','zebra','crucian'] },
            carp: { isSchooling: true, isPredator: false, schoolSize: 6, preyTypes: [] },
            ghost: { isSchooling: true, isPredator: false, schoolSize: 6, preyTypes: [] },
            carp2: { isSchooling: true, isPredator: false, schoolSize: 6, preyTypes: [] },
            koi: { isSchooling: true, isPredator: false, schoolSize: 6, preyTypes: [] },
            crucian: { isSchooling: true, isPredator: false, schoolSize: 10, preyTypes: [] },
            catfish: { isSchooling: false, isPredator: true, schoolSize: 0, preyTypes: ['minnow', 'crappie','guppy','goldfish','tetra','perch','bluegill','zebra','crucian'] },
            flathead: { isSchooling: false, isPredator: true, schoolSize: 0, preyTypes: ['minnow', 'crappie','guppy','goldfish','tetra','perch','bluegill','zebra','crucian'] },
            channel: { isSchooling: false, isPredator: true, schoolSize: 0, preyTypes: ['minnow', 'crappie','guppy','goldfish','tetra','perch','bluegill','zebra','crucian'] },
            bullhead: { isSchooling: true, isPredator: true, schoolSize: 10, preyTypes: ['minnow','guppy','tetra','zebra'] },
            trout: { isSchooling: true, isPredator: true, schoolSize: 6, preyTypes: ['minnow','guppy','tetra','zebra'] },
            salmon: { isSchooling: true, isPredator: true, schoolSize: 6, preyTypes: ['minnow','guppy','tetra','zebra'] },
            salmon2: { isSchooling: true, isPredator: true, schoolSize: 6, preyTypes: ['minnow','guppy','tetra','zebra'] },
            herring: { isSchooling: true, isPredator: true, schoolSize: 20, preyTypes: [] },
            walleye: { isSchooling: true, isPredator: true, schoolSize: 5, preyTypes: ['minnow','guppy','tetra','perch','bluegill','zebra'] },
            crappie: { isSchooling: true, isPredator: true, schoolSize: 15, preyTypes: [] },
            bluegill: { isSchooling: true, isPredator: true, schoolSize: 15, preyTypes: [] },
            perch: { isSchooling: true, isPredator: true, schoolSize: 15, preyTypes: [] },
            goldfish: { isSchooling: true, isPredator: false, schoolSize: 15, preyTypes: [] },
            guppy: { isSchooling: true, isPredator: false, schoolSize: 30, preyTypes: [] },
            tetra: { isSchooling: true, isPredator: false, schoolSize: 30, preyTypes: [] },
            zebra: { isSchooling: true, isPredator: false, schoolSize: 30, preyTypes: [] },
            minnow: { isSchooling: true, isPredator: false, schoolSize: 30, preyTypes: [] }
        };
        const fishSpeedFactors = {
            beluga: 0.8,
            sturgeon: 0.8,
            pike: 1.1,
            largemouth: 1,
            smallmouth: 1.1,
            spotted: 1.1,
            carp: 0.9,
            ghost: 0.9,
            carp2: 0.8,
            koi: 0.9,
            crucian: 0.7,
            catfish: 0.8,
            flathead: 0.8,
            channel: 0.8,
            bullhead: 0.8,
            trout: 1.1,
            salmon: 1.1,
            salmon2: 1.1,
            herring: 0.9,
            walleye: 1,
            crappie: 0.7,
            bluegill: 0.7,
            perch: 0.7,
            goldfish: 0.7,
            guppy: 0.7,
            tetra: 0.7,
            zebra: 0.7,
            minnow: 0.7
        };
        const reproductionDelayMultiplier = {
            beluga: 2.5,
            sturgeon: 2,
            pike: 1.2,
            largemouth: 1.1,
            smallmouth: 1.1,
            spotted: 1.1,
            carp: 1.1,
            ghost: 1.2,
            carp2: 1.1,
            koi: 1.2,
            crucian: 0.9,
            catfish: 1,
            flathead: 1,
            channel: 1,
            bullhead: 1,
            trout: 1,
            salmon: 1,
            salmon2: 1,
            herring: 0.8,
            walleye: 1.1,
            crappie: 0.9,
            bluegill: 0.8,
            perch: 0.8,
            goldfish: 1,
            guppy: 0.7,
            tetra: 0.8,
            zebra: 0.9,
            minnow: 0.8
        };
        // Define an attractor for the school (global attractor variable)
        let attractorCenter = { x: Math.random() * canvas.width, y: Math.random() * canvas.height };
        let attractorChangeTime = Date.now() + 10000 + Math.random() * 10000; // Change attractor every 10-20 seconds

        function updateAttractor() {
            const now = Date.now();
            if (now > attractorChangeTime) {
                attractorCenter = { 
                    x: Math.random() * canvas.width, 
                    y: Math.random() * canvas.height 
                };
                attractorChangeTime = now + 10000 + Math.random() * 10000; // Change again in 10-20 seconds
            }
        }
        let spookCenter = null;
        let spookRadius = 150; // Area of effect
        let spookDuration = 1500; // Duration in milliseconds
        let spookStartTime = 0;

        // Add click event listener
        canvas.addEventListener('click', (event) => {
            const rect = canvas.getBoundingClientRect();
            spookCenter = {
                x: event.clientX - rect.left,
                y: event.clientY - rect.top
            };
            spookStartTime = Date.now();
        });
        class Fish {
            constructor(type, isInitial = true, isOffspring = false, parentVariant = null) {
                if (type === 'goldfish' || type === 'koi'|| type === 'ghost') {
                    if (parentVariant) {
                        this.variant = parentVariant;
                    } else if (isOffspring) {
                        // For offspring, randomly select from available variants in the tank
                        const availableVariants = this.getAvailableVariants(type);
                        this.variant = availableVariants[Math.floor(Math.random() * availableVariants.length)];
                    } else {
                        // For initial or new fish, randomly select from all variants
                        const variants = fishSpecies[type].variants;
                        this.variant = variants[Math.floor(Math.random() * variants.length)];
                    }
                }
                this.type = type;
                this.behavior = fishBehavior[type];
                this.size = this.getRandomSize();
                this.isInitial = isInitial;
                this.isAlive = true;
                const sizeSpeedFactor = Math.sqrt(fishSpecies[type].minSize / this.size);
                const speciesSpeedFactor = fishSpeedFactors[type];
                this.baseSpeed = 2 * sizeSpeedFactor * speciesSpeedFactor;
                this.speed = this.baseSpeed;
                this.schoolCenter = { x: 0, y: 0 };
                this.fleeingFrom = null;
                this.opacity = 1.0;
                this.rotationForDeath = 0;
                this.reset();

                // Hunger system
                this.maxHunger = 100;
                this.hunger = 80;
                this.hungerRate = 0.01;
                this.lastMealTime = Date.now();
                
                // Other properties
                this.birthTime = Date.now();
                const lifespanRange = fishLifeSpans[type];
                this.lifeSpan = Math.random() * (lifespanRange.max - lifespanRange.min) + lifespanRange.min;
                if (isOffspring) {
                    const additionalLifespan = lifespanRange.min / 3;
                    this.lifeSpan += additionalLifespan;
                }

                this.originalSize = this.size;
                this.inSchool = false;
                this.schoolDirection = Math.random() * Math.PI * 2;
                this.schoolChangeTime = Date.now() + Math.random() * 10000;
                this.individualBehavior = Math.random();
                const delayMultiplier = reproductionDelayMultiplier[this.type] || 1;
                this.reproductiveAge = Date.now() + (80000 + Math.random() * 20000) * delayMultiplier;
                this.lastReproduction = 0;
                this.isOffspring = isOffspring;
                this.isAdult = !isOffspring;
                this.lastGrowthTime = Date.now();
                this.verticalMovementScale = 5;
                
                // If offspring, start small
                if (isOffspring) {
                    const smallFishTypes = ["minnow", "perch", "crappie", "guppy", "tetra", "goldfish",  "bluegill", "zebra", "herring"];
                    const sizeFactor = smallFishTypes.includes(type) ? 0.4 : 0.3;

                    this.size = fishSpecies[type].minSize * sizeFactor; // Scale size based on type
                    this.originalSize = this.size; // Set original size
                    this.hunger = 60; // Give offspring a bit more initial hunger
                }
                this.isFoodPresent = false;
                this.causeOfDeath = null;
                // Add initial diving behavior
                this.initialDiveTime = Date.now() + 2000 + Math.random() * 1000;
                this.isDiving = !isOffspring && !isInitial == true;
                // Enhance bottom dwelling behavior
                this.preferredDepth = this.getPreferredDepth();
                this.depthAdjustmentRate = type === 'sturgeon' || type === 'catfish' ? 0.2 : 0.1;
            }
            getAvailableVariants(type) {
                // Get all living adult fish of the same type
                const adultFish = fishArray.filter(f => 
                    f.type === type && 
                    f.isAlive && 
                    f.isAdult
                );

                // Get unique variants present in the tank
                const uniqueVariants = new Set();
                adultFish.forEach(fish => {
                    uniqueVariants.add(fish.variant);
                });

                // If no variants found (shouldn't happen), fallback to all variants
                if (uniqueVariants.size === 0) {
                    return fishSpecies[type].variants;
                }

                return Array.from(uniqueVariants);
            }
            checkHunger() {
                this.hunger -= this.hungerRate;
                if (this.hunger < 0) {
                    this.hunger = 0;
                }
                if (this.hunger === 0) {
                    this.isAlive = false;
                    this.causeOfDeath = 'starvation';
                }
            }
            canEatMore() {
                return this.hunger < 75;
            }
            checkReproduction() {
                if (!this.isAlive || this.fleeingFrom) return;

                if (!this.isAdult || this.size < fishSpecies[this.type].minSize) return;

                const now = Date.now();

                const baseReproductionCooldown = 120000;
                const cooldown = baseReproductionCooldown * (reproductionDelayMultiplier[this.type] || 1);

                const minSize = fishSpecies[this.type].minSize;
                if (minSize >= 25) {
                    const sizePenalty = 1 + (minSize - 25) / 50;
                    const baseThreshold = 1500;
                    const populationThreshold = Math.floor((1 / minSize) * baseThreshold / sizePenalty);
                    const currentPopulation = fishArray.filter(f => f.type === this.type && f.isAlive).length;
                    if (currentPopulation >= populationThreshold) {
                        return;
                    }
                }

                if (now > this.reproductiveAge && now - this.lastReproduction > cooldown) {
                    const mates = fishArray.filter(f => 
                        f.type === this.type &&
                        f !== this &&
                        f.isAlive &&
                        f.isAdult &&
                        f.size >= fishSpecies[this.type].minSize &&
                        now > f.reproductiveAge &&
                        this.distanceTo(f) < this.size * 3
                    );

                    if (mates.length > 0) {
                        const baseOffspring = Math.random() < 0.05 ? 1 : 2;
                        const bonusOffspring = ["guppy", "goldfish", "minnow","tetra","bluegill", "zebra"].includes(this.type) ? Math.floor(Math.random() * 2) : 0;
                        const offspringCount = baseOffspring + bonusOffspring;

                        for (let i = 0; i < offspringCount; i++) {
                            // Pass parent's variant for offspring
                            const offspring = new Fish(this.type, false, true, this.variant);
                            offspring.x = this.x + (Math.random() - 0.5) * this.size;
                            offspring.y = this.y + (Math.random() - 0.5) * this.size;
                            fishArray.push(offspring);
                        }

                        this.lastReproduction = now;
                        updateFishCount();
                    }
                }
            }

            getRandomSize() {
                const species = fishSpecies[this.type];
                return Math.random() * (species.maxSize - species.minSize) + species.minSize;
            }

            reset() {
                if (this.isInitial) {
                    // Initial fish start within bounds
                    this.x = Math.random() * (canvas.width - 100) + 50;
                    this.y = Math.random() * (canvas.height - 100) + 50;
                } else {
                    // New fish only enter from top
                    this.x = Math.random() * canvas.width;
                    this.y = -this.size;
                }
                
                // Face the direction of movement
                this.angle = Math.random() < 0.5 ? 0 : Math.PI; // 0 for right, PI for left
                this.targetAngle = this.angle;
                this.speed = this.baseSpeed * globalSpeedMultiplier;
            }
            
            canEat(prey) {
                // Avoid eating the same species unless hunger-driven
                if (this.type === prey.type && this.hunger >= 20) {
                    return false; // Don't eat its own species unless very hungry
                }

                const isPredator = this.behavior.isPredator;
                const preyIsPredator = prey.behavior.isPredator;

                // Adjust for sturgeon and beluga-specific behavior
                const isLargePredator = this.type === 'sturgeon' || this.type === 'beluga';

                // Traditional predator-prey relationship
                const isPredatorPreyMatch = isPredator &&
                                            this.behavior.preyTypes.includes(prey.type) &&
                                            this.size >= prey.size * (isLargePredator ? 4 : 1.5);

                // Predators eating smaller predators (not the same species)
                const isPredatorEatingSmallPredator = isPredator &&
                                                    preyIsPredator &&
                                                    this.type !== prey.type &&
                                                    this.size >= prey.size * (isLargePredator ? 4 : 2.5);

                // Hunger-driven opportunistic predation
                const isHungerDriven = this.hunger < 20 &&
                                    (isPredator
                                            ? prey.size <= this.size * (isLargePredator ? 0.3 : 0.45)
                                            : prey.size <= this.size * 0.2);

                return isPredatorPreyMatch || isPredatorEatingSmallPredator || isHungerDriven;
            }

            updateSchooling() {
                if (this.behavior.isSchooling) {
                    // Find nearby fish of same type within school range
                    const schoolmates = fishArray.filter(f => 
                        f.type === this.type && 
                        f !== this && 
                        f.isAlive &&
                        this.distanceTo(f) < 150
                    );

                    // Get all nearby fish for collision avoidance
                    const nearbyFish = fishArray.filter(f => 
                        f !== this && 
                        f.isAlive &&
                        this.distanceTo(f) < (this.size + f.size) * 1.5
                    );

                    // Update school membership
                    if (schoolmates.length > 0) {
                        if (!this.inSchool && this.individualBehavior > 0.3) {
                            this.inSchool = true;
                        } else if (this.inSchool && this.individualBehavior < 0.2) {
                            this.inSchool = false;
                        }
                    } else {
                        this.inSchool = false;
                    }

                    // Calculate schooling behavior
                    if (this.inSchool && schoolmates.length > 0) {
                        let cohesionX = 0, cohesionY = 0;      // Center of school
                        let alignmentX = 0, alignmentY = 0;     // Average direction
                        let separationX = 0, separationY = 0;   // Keep distance from schoolmates
                        let avoidanceX = 0, avoidanceY = 0;     // Avoid other fish species

                        // Calculate cohesion and alignment
                        schoolmates.forEach(f => {
                            // Cohesion - move toward center of school
                            cohesionX += f.x;
                            cohesionY += f.y;

                            // Alignment - match school's direction
                            const angleVector = {
                                x: Math.cos(f.angle),
                                y: Math.sin(f.angle)
                            };
                            alignmentX += angleVector.x;
                            alignmentY += angleVector.y;

                            // Separation - maintain minimum distance from schoolmates
                            const dist = this.distanceTo(f);
                            const minDist = (this.size + f.size) * 1;
                            if (dist < minDist) {
                                separationX += (this.x - f.x) / (dist || 1) * (minDist - dist);
                                separationY += (this.y - f.y) / (dist || 1) * (minDist - dist);
                            }
                        });

                        // Calculate avoidance of other fish species
                        nearbyFish.forEach(f => {
                            if (f.type !== this.type) {
                                const dist = this.distanceTo(f);
                                const minDist = (this.size + f.size) * 1.2;
                                if (dist < minDist) {
                                    avoidanceX += (this.x - f.x) / (dist || 1);
                                    avoidanceY += (this.y - f.y) / (dist || 1);
                                }
                            }
                        });

                        const schoolCenter = {
                            x: schoolmates.reduce((sum, f) => sum + f.x, 0) / schoolmates.length,
                            y: schoolmates.reduce((sum, f) => sum + f.y, 0) / schoolmates.length
                        };

                        const angleToSchoolCenter = Math.atan2(schoolCenter.y - this.y, schoolCenter.x - this.x);
                        const distanceToSchoolCenter = Math.sqrt(Math.pow(schoolCenter.x - this.x, 2) + Math.pow(schoolCenter.y - this.y, 2));

                        const circularSchoolingStrength = 0.1;
                        const circularSchoolingRadius = Math.min(canvas.width, canvas.height) / 4 + schoolmates.length * 5;

                        let circularSchoolingX = 0;
                        let circularSchoolingY = 0;

                        if (distanceToSchoolCenter > circularSchoolingRadius) {
                            circularSchoolingX = Math.cos(angleToSchoolCenter + Math.PI / 2) * circularSchoolingStrength;
                            circularSchoolingY = Math.sin(angleToSchoolCenter + Math.PI / 2) * circularSchoolingStrength;
                        } else {
                            circularSchoolingX = Math.cos(angleToSchoolCenter - Math.PI / 2) * circularSchoolingStrength;
                            circularSchoolingY = Math.sin(angleToSchoolCenter - Math.PI / 2) * circularSchoolingStrength;
                        }

                        // Complex schooling behavior
                        const schoolingStrength = 0.05;
                        const schoolingTorque = 0.1;

                        const schoolingX = (cohesionX / schoolmates.length - this.x) * schoolingStrength;
                        const schoolingY = (cohesionY / schoolmates.length - this.y) * schoolingStrength;

                        const alignmentStrength = alignmentX * schoolingStrength;
                        const alignmentTorque = alignmentY * schoolingTorque;

                        const separationStrength = separationX * schoolingStrength * 2;
                        const separationTorque = separationY * schoolingTorque * 2;

                        const avoidanceStrength = avoidanceX * schoolingStrength * 3;
                        const avoidanceTorque = avoidanceY * schoolingTorque * 3;

                        // Calculate final target position
                        const targetX = this.x + schoolingX + separationStrength + avoidanceStrength + circularSchoolingX;
                        const targetY = this.y + schoolingY + separationTorque + avoidanceTorque + circularSchoolingY;

                        // Calculate desired angle
                        let desiredAngle = Math.atan2(targetY - this.y, targetX - this.x);
                        if (Math.abs(desiredAngle - this.angle) > Math.PI) {
                            this.angle = desiredAngle;
                        }
                        // Apply alignment torque
                        desiredAngle += alignmentTorque;

                        // Smooth turning
                        let angleDiff = desiredAngle - this.angle;
                        while (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;
                        while (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;

                        // Limit turn rate
                        angleDiff = Math.max(Math.min(angleDiff, Math.PI / 8), -Math.PI / 8);
                        this.targetAngle = this.angle + angleDiff;
                        this.angle = this.lerpAngle(this.angle, this.targetAngle, 0.05);

                        // Adjust speed based on position in school
                        const distToCenter = Math.sqrt(
                            Math.pow(targetX - this.x, 2) +
                            Math.pow(targetY - this.y, 2)
                        );

                        if (distToCenter > this.size * 6) {
                            this.speed = this.baseSpeed * 1.2; // Speed up to catch school
                        } else if (distToCenter < this.size * 2) {
                            this.speed = this.baseSpeed * 0.6; // Slow down if too close
                        } else {
                            this.speed = this.baseSpeed;
                        }
                    } else {
                        // Individual movement when not in school
                        if (Math.random() < 0.02) {
                            this.targetAngle += (Math.random() - 0.5) * Math.PI / 4;
                        }
                    }

                    // Handle boundaries
                    const margin = 0;
                    if (this.x < margin || this.x > canvas.width - margin) {
                        this.schoolDirection = this.x < margin ? 0 : Math.PI;
                        this.targetAngle = this.schoolDirection;
                    }
                }
            }

            updatePredatorBehavior() {
                // Only hunt if hungry enough
                if (this.canEatMore()) {
                    let nearestPrey = null;
                    let minDistance = 220;  // Detection radius

                    fishArray.forEach(f => {
                        if (f.isAlive && this.canEat(f)) {
                            const dist = this.distanceTo(f);
                            if (dist < minDistance) {
                                minDistance = dist;
                                nearestPrey = f;
                            }
                        }
                    });

                    if (nearestPrey) {
                        if (minDistance < this.size / 2) {
                            nearestPrey.causeOfDeath = 'eaten';
                            nearestPrey.isAlive = false;

                            // Immediately remove eaten fish
                            const index = fishArray.indexOf(nearestPrey);
                            if (index > -1) {
                                fishArray.splice(index, 1);
                                updateFishCount(); // Update the count
                            }

                            // Adjust size and hunger gain based on prey size
                            if (nearestPrey.size > this.size * 0.4) {
                                this.size = Math.min(this.size + 5 + Math.random() * 3, fishSpecies[this.type].maxSize); // Larger prey
                                this.hunger = Math.min(this.hunger + 32, 100);
                            } else if (nearestPrey.size > this.size * 0.2) {
                                this.size = Math.min(this.size + 3 + Math.random() * 2, fishSpecies[this.type].maxSize); // Medium prey
                                this.hunger = Math.min(this.hunger + 16, 100);
                            } else {
                                this.size = Math.min(this.size + 1 + Math.random() * 1, fishSpecies[this.type].maxSize); // Smaller prey
                                this.hunger = Math.min(this.hunger + 8, 100);
                            }

                            this.lastMealTime = Date.now();
                            return;
                        }
                        // Adjust speed based on distance
                        if (minDistance < 80) {
                            this.speed = this.baseSpeed * 2.5; // Final sprint
                        } else if (minDistance < 160) {
                            this.speed = this.baseSpeed * 2; // Chase speed
                        } else {
                            this.speed = this.baseSpeed * 1.5; // Approach speed
                        }
                        // Chase behavior
                        const angleToTarget = Math.atan2(
                            nearestPrey.y - this.y,
                            nearestPrey.x - this.x
                        );
                        if (Math.abs(angleToTarget - this.angle) > Math.PI) {
                            this.angle = angleToTarget;
                        }
                        // Adjust angle based on prediction of prey movement
                        if (nearestPrey.fleeingFrom === this) {
                            const predictionFactor = 1.5;
                            const predictedX = nearestPrey.x + Math.cos(nearestPrey.angle) * nearestPrey.speed * predictionFactor;
                            const predictedY = nearestPrey.y + Math.sin(nearestPrey.angle) * nearestPrey.speed * predictionFactor;
                            this.targetAngle = Math.atan2(predictedY - this.y, predictedX - this.x);
                        } else {
                            this.targetAngle = angleToTarget;
                        }

                        // Smooth turning
                        this.angle = this.lerpAngle(this.angle, this.targetAngle, 0.05);

                        // Mark prey as being chased
                        nearestPrey.fleeingFrom = this;
                    } else {
                        // Return to normal speed when not chasing
                        this.speed = this.baseSpeed;
                    }
                } else {
                    // Not hungry enough to hunt
                    this.speed = this.baseSpeed;
                }
            }

            updatePreyBehavior() {
                if (this.fleeingFrom) {
                    // Flee from predator
                    const angleAway = Math.atan2(
                        this.y - this.fleeingFrom.y,
                        this.x - this.fleeingFrom.x
                    );
                    if (Math.abs(angleAway - this.angle) > Math.PI) {
                        this.angle = angleAway;
                    }
                    this.targetAngle = angleAway;
                    this.angle = this.lerpAngle(this.angle, this.targetAngle, 0.15);
                    this.speed = this.baseSpeed * 1.3; // Flee faster
                    
                    if (this.distanceTo(this.fleeingFrom) > 150) {
                        this.fleeingFrom = null;
                    }
                } else {
                    this.speed = this.baseSpeed;
                }
            }

            checkForFood() {
                if (this.isAlive && this.canEatMore()) {
                    for (let pellet of foodPellets) {
                        if (!pellet.consumed) {
                            const dist = Math.sqrt(
                                Math.pow(this.x - pellet.x, 2) +
                                Math.pow(this.y - pellet.y, 2)
                            );

                            if (dist < 100) { // Detection radius
                                // Move towards food
                                const angleToFood = Math.atan2(pellet.y - this.y, pellet.x - this.x);
                                this.targetAngle = angleToFood;
                                this.speed = this.baseSpeed * 1.5; // Increased speed when chasing food

                                if (dist < this.size / 2) {
                                    pellet.consumed = true;
                                    this.grow();
                                    this.lastMealTime = Date.now();
                                    this.hunger = Math.min(this.hunger + 15, 100);
                                }
                                return true;
                            }
                        }
                    }
                    return false;
                } else {
                    return false;
                }
            }
            distanceTo(other) {
                const dx = other.x - this.x;
                const dy = other.y - this.y;
                return Math.sqrt(dx * dx + dy * dy);
            }

            lerpAngle(a, b, t) {
                const diff = b - a;
                return a + diff * t;
            }
            getPreferredDepth() {
                const preference = fishSpecies[this.type].depthPreference;
                const margin = 100;
                
                switch(preference) {
                    case 'bottom':
                        return canvas.height - margin - Math.random() * 100;
                    case 'top':
                        return margin + Math.random() * 100;
                    default: // 'middle'
                        return canvas.height/2 + (Math.random() - 0.5) * 200;
                }
            }
            checkSpook() {
                if (!spookCenter) return;
                
                const timeSinceSpook = Date.now() - spookStartTime;
                if (timeSinceSpook > spookDuration) {
                    spookCenter = null;
                    return;
                }

                const distToSpook = Math.sqrt(
                    Math.pow(this.x - spookCenter.x, 2) + 
                    Math.pow(this.y - spookCenter.y, 2)
                );

                if (distToSpook < spookRadius) {
                    // Calculate angle away from spook point
                    const angleAway = Math.atan2(
                        this.y - spookCenter.y,
                        this.x - spookCenter.x
                    );
                    
                    // Stronger reaction for closer fish
                    const intensityFactor = 1 - (distToSpook / spookRadius);
                    this.speed = this.baseSpeed * (2 + intensityFactor * 2);
                    
                    // Turn away from spook point
                    this.targetAngle = angleAway;
                    this.angle = this.lerpAngle(this.angle, this.targetAngle, 0.3);
                    
                    // Break from schooling temporarily
                    this.inSchool = false;
                }
            }
            move() {
                if (!this.isAlive) {
                    if (this.causeOfDeath === 'starvation') {
                        this.rotationForDeath = Math.min(this.rotationForDeath + 0.05, Math.PI);
                        this.opacity = Math.max(0, this.opacity - 0.02);

                        if (this.opacity <= 0) {
                            const index = fishArray.indexOf(this);
                            if (index > -1) {
                                fishArray.splice(index, 1);
                            }
                        }
                    } else if (this.causeOfDeath === 'natural' || this.causeOfDeath === 'random') {
                        this.rotationForDeath = Math.min(this.rotationForDeath + 0.05, Math.PI);
                        this.opacity = Math.max(0, this.opacity - 0.02);

                        if (this.opacity <= 0) {
                            const index = fishArray.indexOf(this);
                            if (index > -1) {
                                fishArray.splice(index, 1);
                            }
                        }
                    }
                    return;
                }
                // Ensure minimum speed to avoid freezing
                if (this.speed < 0.1) {
                    this.speed = this.baseSpeed * 0.5; // Set a fallback speed
                }
                if (this.isDiving && Date.now() < this.initialDiveTime) {
                    const targetDepth = canvas.height * 1.5;
                    if (this.y < targetDepth) {
                        this.y += this.speed * 0.8;
                    }
                    return;
                }
                this.isDiving = false;
                this.checkHunger();
                this.checkReproduction();

                const foodExists = foodPellets.length > 0;
                let isChasing = false;

                if (foodExists && this.canEatMore()) {
                    // Food chasing logic
                    let nearestFood = null;
                    let minDistance = Infinity;

                    for (let pellet of foodPellets) {
                        if (!pellet.consumed) {
                            const dist = this.distanceTo(pellet);
                            if (dist < minDistance) {
                                minDistance = dist;
                                nearestFood = pellet;
                            }
                        }
                    }
                    if (this.canEatMore() && this.updatePredatorBehavior()) {
                        return; // Predator behavior takes precedence
                    }
                    if (nearestFood) {
                        // Move towards nearest food
                        const angleToFood = Math.atan2(
                            nearestFood.y - this.y,
                            nearestFood.x - this.x
                        );
                        this.targetAngle = angleToFood;
                        this.angle = this.lerpAngle(this.angle, this.targetAngle, 0.1);

                        if (minDistance < this.size / 2) {
                            nearestFood.consumed = true;
                            this.grow();
                            this.lastMealTime = Date.now();
                            this.hunger = Math.min(this.hunger + 20, 100);
                        }

                        // Move faster towards food if close
                        this.speed = minDistance < 180 ? this.baseSpeed * 1.8 : this.baseSpeed;
                    }
                } else {
                    this.updateSchooling();
                    if (this.behavior.isPredator) {
                        this.updatePredatorBehavior();
                    }
                    this.updatePreyBehavior();

                    // Apply depth preferences more strongly for bottom dwellers
                    if (fishSpecies[this.type].depthPreference === 'bottom') {
                        const targetDepth = canvas.height * 0.85;
                        const depthDiff = targetDepth - this.y;

                        if (depthDiff > 0) {
                            // Gradually move towards preferred depth
                            this.y += depthDiff * this.depthAdjustmentRate * 0.02;
                        }

                        // Reduce vertical movement for bottom dwellers
                        this.verticalMovementScale = 1;
                    } else {
                        // Random vertical movement for other fish
                        if (!this.fleeingFrom && Math.random() < 0.02) {
                            this.y += (Math.random() - 0.5) * this.verticalMovementScale;
                        }
                    }

                    if (fishSpecies[this.type].depthPreference === 'top') {
                        // Only apply gentle top tendency when not chasing food/escaping
                        if (!this.fleeingFrom && !this.chasingFood) {
                            const topTarget = canvas.height * 0.3; // Prefer upper 30% of tank
                            if (this.y > topTarget && Math.random() < 0.05) { // Gentle upward tendency
                                this.y -= this.speed * 0.2; // Gentle upward drift
                            }

                            // Allow occasional downward exploration
                            if (Math.random() < 0.02) {
                                this.y += this.speed * 0.1; 
                            }

                            // Prevent staying too close to surface
                            if (this.y < canvas.height * 0.1) { // Too close to surface
                                this.y += this.speed * 0.05; // Gentle push down
                            }
                        }
                    }
                }

                if (!this.fleeingFrom && !this.chasingFood) {
                    if (Math.random() < 0.005) {
                        // If currently moving left, switch to right and vice versa
                        if (Math.abs(this.angle) > Math.PI / 2) {
                            this.targetAngle = 0;  // Switch to moving right
                        } else {
                            this.targetAngle = Math.PI;  // Switch to moving left
                        }
                    }

                    // Smooth turn towards target angle
                    if (this.targetAngle !== this.angle) {
                        const turnSpeed = 0.02;
                        let angleDiff = this.targetAngle - this.angle;

                        // Normalize angle difference
                        while (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;
                        while (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;

                        this.angle += angleDiff * turnSpeed;
                    }

                    // Occasionally make small adjustments to vertical position
                    if (Math.random() < 0.01) { // 1% chance each frame
                        this.y += (Math.random() - 0.5) * 2; // Small vertical adjustment
                    }
                }

                // Adding Buoyancy to Help Offset Sinking
                const buoyancyForce = 0.05;  // Adjust this value for desired upward effect
                this.y -= buoyancyForce;

                this.checkSpook();
                // Update Position and Handle Boundaries More Aggressively
                this.x += Math.cos(this.angle) * this.speed;
                this.y += Math.sin(this.angle) * this.speed * 0.7;

                const margin = 20;
                const bottomMargin = 50;

                // Enhanced Boundary Handling to Prevent Stacking at Corners
                if (this.x < margin) {
                    this.x = margin;
                    this.targetAngle = Math.random() * Math.PI / 2; // Turn towards the right
                    this.angle = this.targetAngle;
                } else if (this.x > canvas.width - margin) {
                    this.x = canvas.width - margin;
                    this.targetAngle = Math.PI + Math.random() * Math.PI / 2; // Turn towards the left
                    this.angle = this.targetAngle;
                }

                if (this.y < margin) {
                    this.y = margin;
                    this.targetAngle = Math.PI / 2 + Math.random() * Math.PI / 2; // Turn downwards
                    this.angle = this.targetAngle;
                } else if (this.y > canvas.height - bottomMargin) {
                    this.y = canvas.height - bottomMargin;
                    if (!this.isAlive) {
                        // If fish is dead, apply natural sinking behavior
                        this.targetAngle = Math.PI; // Set angle for a downward movement if necessary
                    } else if (this.canEatMore() || this.fleeingFrom) {
                        // If the fish is hungry or fleeing, ensure an aggressive turn upwards to move away from the bottom
                        this.targetAngle = -Math.PI / 2 + Math.random() * Math.PI / 2; // Turn upwards
                    } else {
                        // For fish that are not fleeing or hungry, gently encourage them to turn upwards
                        this.targetAngle = -Math.PI / 3 + Math.random() * Math.PI / 3; // More subtle turn upwards
                    }
                    this.angle = this.lerpAngle(this.angle, this.targetAngle, 0.1); // Smoothly change direction upwards
                }
            }

            grow() {
                const currentTime = Date.now();
                if (currentTime - this.lastGrowthTime < 1000) {
                    return;
                }
                this.lastGrowthTime = currentTime;

                const speciesMaxSize = fishSpecies[this.type].maxSize;
                const speciesMinSize = fishSpecies[this.type].minSize;
                // Calculate species size range to determine growth rate
                const sizeRange = speciesMinSize;
                const growthMultiplier = sizeRange / 30; // Base multiplier on size range
                
                if (!this.isAdult) {
                    // Juvenile growth
                    const baseGrowthRate = 3 + Math.random() * 2;
                    const growthAmount = baseGrowthRate * growthMultiplier;
                    this.size = Math.min(this.size + growthAmount, speciesMinSize);
                    
                    // Check if reached adult size
                    if (this.size >= speciesMinSize) {
                        this.isAdult = true;
                        const minLifespan = fishLifeSpans[this.type].min;
                        const bonusLifespan = minLifespan * 0.3;
                        this.lifeSpan += bonusLifespan;
                    }
                } else {
                    // Adult growth
                    const baseGrowthRate = 2 + Math.random() * 1;
                    const growthAmount = baseGrowthRate * growthMultiplier;
                    this.size = Math.min(this.size + growthAmount, speciesMaxSize);
                }
            }
            checkLifespan() {
                const age = Date.now() - this.birthTime;
                const timeSinceLastMeal = Date.now() - this.lastMealTime;
                
                if (age > this.lifeSpan || timeSinceLastMeal > this.lifeSpan / 2) {
                    this.isAlive = false;
                    this.causeOfDeath = 'natural';
                }
            }
            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                
                if (!this.isAlive) {
                    ctx.rotate(this.rotationForDeath);
                    ctx.globalAlpha = this.opacity;
                }

                const movingLeft = Math.abs(this.angle) > Math.PI/2;

                ctx.scale(-1, 1);

                if (movingLeft) {
                    ctx.scale(-1, 1);
                }

                const imageKey = (this.variant && (this.type === 'goldfish' || this.type === 'koi'|| this.type === 'ghost')) 
                    ? this.variant 
                    : this.type;

                ctx.drawImage(
                    fishImages[imageKey],
                    -this.size/2,
                    -this.size/2,
                    this.size,
                    this.size
                );
                ctx.restore();
            }
        }

        let isDarkMode = true; // Start with dark mode by default

        let surfaceLights = [];
        const LIGHT_COUNT = 10;

        function initializeSurfaceLights() {
            surfaceLights = [];
            for (let i = 0; i < LIGHT_COUNT; i++) {
                surfaceLights.push({
                    x: Math.random() * canvas.width,
                    intensity: 0.2 + Math.random() * 0.4,
                    speed: 0.1 + Math.random() * 0.2,
                    width: 100 + Math.random() * 200
                });
            }
        }
        function animateBackground() {
            drawNaturalBackground();
        }
        function drawNaturalBackground() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            if (isDarkMode) {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            } else {
                // Enhanced gradient for water - darker at bottom
                let gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
                gradient.addColorStop(0, 'rgba(0, 75, 65, 0.9)');     // Dark green at top
                gradient.addColorStop(0.5, 'rgba(0, 45, 40, 0.95)');  // Darker middle
                gradient.addColorStop(1, 'rgba(0, 25, 20, 0.98)');    // Even darker bottom
                
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // Draw surface light effects
                surfaceLights.forEach(light => {
                    // Update light position
                    light.x += light.speed;
                    if (light.x > canvas.width + light.width) {
                        light.x = -light.width;
                    }

                    let beamGradient = ctx.createRadialGradient(
                        light.x, 0, 0,
                        light.x, 0, light.width
                    );
                    
                    beamGradient.addColorStop(0, `rgba(255, 250, 240, ${light.intensity * 0.2})`);
                    beamGradient.addColorStop(0.5, `rgba(240, 240, 230, ${light.intensity * 0.1})`);
                    beamGradient.addColorStop(1, 'rgba(255, 255, 255, 0)');

                    ctx.fillStyle = beamGradient;
                    
                    ctx.beginPath();
                    ctx.moveTo(light.x - light.width/2, 0);
                    ctx.lineTo(light.x + light.width/2, 0);
                    ctx.lineTo(light.x + light.width, canvas.height);
                    ctx.lineTo(light.x - light.width, canvas.height);
                    ctx.closePath();
                    ctx.fill();
                });
            }
        }

        function updateBackground() {
            if (fishArray.length === 0) {
                // If no fish, just draw the background once
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                if (!isDarkMode) {
                    let gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
                    gradient.addColorStop(0, 'rgba(0, 75, 65, 0.9)');
                    gradient.addColorStop(0.5, 'rgba(0, 45, 40, 0.95)');
                    gradient.addColorStop(1, 'rgba(0, 25, 20, 0.98)');
                    
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                } else {
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                }
            }
        }

        function toggleDayNight() {
            isDarkMode = !isDarkMode;
            
            if (!isDarkMode) {
                // Always initialize surface lights when switching to day mode if they don't exist
                if (surfaceLights.length === 0) {
                    initializeSurfaceLights();
                }

                // Start animating surface lights even without fish
                function animateSurfaceLights() {
                    if (!isDarkMode) {  // Keep animating as long as in day mode
                        ctx.clearRect(0, 0, canvas.width, canvas.height);
                        
                        // Draw gradient background
                        let gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
                        gradient.addColorStop(0, 'rgba(0, 75, 65, 0.9)');
                        gradient.addColorStop(0.5, 'rgba(0, 45, 40, 0.95)');
                        gradient.addColorStop(1, 'rgba(0, 25, 20, 0.98)');
                        
                        ctx.fillStyle = gradient;
                        ctx.fillRect(0, 0, canvas.width, canvas.height);
                        
                        // Animate surface lights
                        surfaceLights.forEach(light => {
                            light.x += light.speed;
                            if (light.x > canvas.width + light.width) {
                                light.x = -light.width;
                            }

                            let beamGradient = ctx.createRadialGradient(
                                light.x, 0, 0,
                                light.x, 0, light.width
                            );
                            
                            beamGradient.addColorStop(0, `rgba(255, 250, 240, ${light.intensity * 0.2})`);
                            beamGradient.addColorStop(0.5, `rgba(240, 240, 230, ${light.intensity * 0.1})`);
                            beamGradient.addColorStop(1, 'rgba(255, 255, 255, 0)');

                            ctx.fillStyle = beamGradient;
                            
                            ctx.beginPath();
                            ctx.moveTo(light.x - light.width/2, 0);
                            ctx.lineTo(light.x + light.width/2, 0);
                            ctx.lineTo(light.x + light.width, canvas.height);
                            ctx.lineTo(light.x - light.width, canvas.height);
                            ctx.closePath();
                            ctx.fill();
                        });
                        
                        requestAnimationFrame(animateSurfaceLights);
                    }
                }

                // Start the animation if there are no fish
                if (!fishActive) {
                    animateSurfaceLights();
                }
            }
            
            const toggleButton = document.querySelector('.control-button[onclick="toggleDayNight()"]');
            toggleButton.innerHTML = isDarkMode ? "Mode: ðŸŒ™" : "Mode: ðŸŒž";
            
            const overlay = document.createElement('div');
            overlay.style.position = 'fixed';
            overlay.style.top = '0';
            overlay.style.left = '0';
            overlay.style.width = '100%';
            overlay.style.height = '100%';
            overlay.style.backgroundColor = isDarkMode ? 'rgba(0, 0, 0, 0.5)' : 'rgba(0, 75, 65, 0.5)';
            overlay.style.transition = 'opacity 2s';
            overlay.style.pointerEvents = 'none';
            overlay.style.zIndex = '1';
            document.body.appendChild(overlay);

            setTimeout(() => {
                overlay.style.opacity = '0';
                setTimeout(() => {
                    overlay.remove();
                }, 2000);
            }, 100);

            updateBackground();

            if (fishArray.length > 0) {
                const speedMultiplier = isDarkMode ? 0.9 : 1;
                fishArray.forEach(fish => {
                    fish.speed = fish.baseSpeed * speedMultiplier;
                });
            }
        }

        function drawFish() {
            // Clear canvas first
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw appropriate background first
            if (!isDarkMode) {
                // Draw day mode background without light effects
                let gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
                gradient.addColorStop(0, 'rgba(0, 75, 65, 0.9)');     // Dark green at top
                gradient.addColorStop(0.5, 'rgba(0, 45, 40, 0.95)');  // Darker middle
                gradient.addColorStop(1, 'rgba(0, 25, 20, 0.98)');    // Even darker bottom
                
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // Draw light effects
                surfaceLights.forEach(light => {
                    // Only update positions if animation is active
                    if (animationActive) {
                        light.x += light.speed;
                        if (light.x > canvas.width + light.width) {
                            light.x = -light.width;
                        }
                    }

                    let beamGradient = ctx.createRadialGradient(
                        light.x, 0, 0,
                        light.x, 0, light.width
                    );
                    
                    beamGradient.addColorStop(0, `rgba(255, 250, 240, ${light.intensity * 0.2})`);
                    beamGradient.addColorStop(0.5, `rgba(240, 240, 230, ${light.intensity * 0.1})`);
                    beamGradient.addColorStop(1, 'rgba(255, 255, 255, 0)');

                    ctx.fillStyle = beamGradient;
                    
                    ctx.beginPath();
                    ctx.moveTo(light.x - light.width/2, 0);
                    ctx.lineTo(light.x + light.width/2, 0);
                    ctx.lineTo(light.x + light.width, canvas.height);
                    ctx.lineTo(light.x - light.width, canvas.height);
                    ctx.closePath();
                    ctx.fill();
                });
            } else {
                // Dark mode background
                ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }

            // Draw food pellets
            for (let i = foodPellets.length - 1; i >= 0; i--) {
                const pellet = foodPellets[i];
                if (animationActive) {
                    if (!pellet.update()) {
                        foodPellets.splice(i, 1);
                        continue;
                    }
                }
                pellet.draw();
            }

            // Draw fish on top
            if (fishArray.length > 0) {
                for (let i = fishArray.length - 1; i >= 0; i--) {
                    const fish = fishArray[i];
                    if (animationActive) {
                        fish.checkLifespan();
                        fish.move();
                    }
                    fish.draw();

                    if (!fish.isAlive && fish.opacity <= 0) {
                        removeFish(fish);
                    }
                }
            }

            // If not actively animating but we have fish, request another frame
            if (!animationActive && fishArray.length > 0) {
                requestAnimationFrame(drawFish);
            }
        }
        function animate() {
            if (!animationActive) return;
            
            updateAttractor();
            drawFish();
            animationFrameId = requestAnimationFrame(animate);
        }
        function stopAnimation() {
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }

            animationActive = false;

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        }
        function toggleAnimation() {
            animationActive = !animationActive;
            const toggleButton = document.querySelector('.control-button[onclick="toggleAnimation()"]');
            
            if (animationActive) {
                toggleButton.textContent = "Playing";
                animate();
            } else {
                toggleButton.textContent = "Paused";
                // Keep drawing frames even when paused
                if (fishArray.length > 0) {
                    drawFish();
                }
            }
        }

        window.addEventListener("resize", () => {
            initializeSurfaceLights();
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        });
    </script>
</body>
</html>