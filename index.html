<!DOCTYPE html>
<html lang="en">
<link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css" rel="stylesheet">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Jianghui Li's Personal Website</title>
    <style>
        @media (min-width: 768px) {
            .section {
                margin: 20px 330px;
                min-width: 540px;
            }

            .about-container {
                flex-direction: row;
                text-align: left;
                min-width: 540px;
            }

            .research-container {
                flex-direction: row;
                text-align: left;
                min-width: 540px;
            }

            #top-menu {
                left: 200px;
                right: 200px;
                border-radius: 0 0 10px 10px;
            }

            #top-menu .nav-link {
                font-size: 24px;
            }
        }

        @media (max-width: 767px) {
            .photo-frame {
                width: 120px;
                height: 160px;
            }

            .research-project {
                margin: 10px 0;
            }

            .section h3 {
                font-size: 20px;
            }

            .section p {
                font-size: 14px;
            }

            #about {
                margin-top: 100px;
            }

            .fish-toggle {
                margin-left: 10px;
            }

            #fishToggle {
                height: 35px;
            }
        }
        body {
            min-width: 1500px;
            margin: 0;
            padding: 0;
            font-family: Arial, sans-serif;
            background-color: black;
            overflow-y: scroll;
            overflow-x: auto;
        }

        canvas {
            position: fixed;
            top: 60px;
            left: 0;
            width: 100%;
            height: calc(100% - 60px);
            z-index: -1;
            pointer-events: none;
        }

        #top-menu {
            position: fixed;
            top: 0;
            left: 200px;
            right: 200px;
            height: 60px;
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            display: flex;
            align-items: center;
            padding: 0 20px;
            z-index: 1000;
            border-radius: 0 0 0 0;
        }

        #top-menu h1 {
            margin: 0;
            font-size: 24px;
            margin-right: 0px;
        }

        #top-menu .nav-link {
            color: #ffc500;
            text-decoration: none;
            margin: 0 15px;
            font-size: 24px;
            position: relative;
            display: inline-block;
        }

        #top-menu .nav-link::after {
            content: ''; /* Placeholder for the underline */
            position: absolute;
            left: 0;
            bottom: -5px; /* Position the underline just below the text */
            width: 0%; /* Start with no underline */
            height: 2px; /* Thickness of the underline */
            background: linear-gradient(90deg, #ffc500, #ff8000, #1eceff); /* Gradient for underline */
            transition: width 1s ease; /* Smoothly expand the underline */
        }

        #top-menu .nav-link:hover {
            color: transparent; /* Hide the default text color */
            background: linear-gradient(90deg, #ffc500, #ff8000, #1eceff); /* Gradient colors */
            background-clip: text; /* Clip gradient to text */
            -webkit-background-clip: text; /* For Safari compatibility */
            transition: background 1s ease; /* Smooth transition for text */
        }

        #top-menu .nav-link:hover::after {
            width: 100%;
        }
        #controls-panel {
            position: fixed;
            top: 60px;
            left: -270px;
            height: calc(100% - 60px);
            width: 170px;
            background-color: rgba(0, 0, 0, 0.5);
            color: white;
            padding: 20px;
            box-shadow: 2px 0 5px rgba(0, 0, 0, 0.5);
            overflow-y: auto;
            transition: left 0.3s ease;
            z-index: 100;
        }

        #controls-panel.active {
            left: 0;
        }

        #toggle-controls {
            position: fixed;
            top: 80px;
            left: 0px;
            background-color: rgba(255, 255, 255, 0.1);
            color: white;
            border: none;
            border-radius: 8px;
            padding: 10px;
            font-size: 16px;
            cursor: pointer;
            z-index: 101;
            transition: left 0.3s ease;
        }

        #controls-panel.active + #toggle-controls {
            left: 190px;
        }

        #toggle-controls::after {
            font-family: "Font Awesome 5 Free";
            content: "\f061";
            font-weight: 900;
            font-size: 18px;
        }

        #toggle-controls.active::after {
            content: "\f060";
        }

        html {
            scroll-behavior: smooth;
        }

        h1 {
            margin: 0px;
            font-size: 20px;
        }

        h3 {
            margin: 0px;
            font-size: 16px;
        }

        .header-title {
            text-align: center;
            color: white;
            margin: 80px 20px 40px 20px;
            text-shadow: 2px 2px 5px rgba(0, 0, 0, 0.8);
        }

        .section {
            margin: 20px 330px 20px 330px;
            color: white;
            text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.8);
            z-index: 1;
            position: relative;
        }
        #click-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0;  /* Between canvas and content */
            pointer-events: auto;  /* Catch all clicks */
        }
        .section h3 {
            font-size: 24px;
            margin-bottom: 20px;
            color: #ffc500;
        }
        .section h4 {
            font-size: 16px;
            margin-bottom: 20px;
            color: #ffc500;
        }

        .section p, .section ul {
            font-size: 16px;
            line-height: 1.8;
        }

        .nav-link {
            color: #ffc500;
            text-decoration: none;
            display: block;
            margin: 10px 0;
            font-size: 16px;
        }

        .nav-link:hover {
            text-decoration: underline;
        }

        .control-button {
            background-color: rgba(255, 255, 255, 0.1);
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            transition: background-color 0.2s;
            width: 100%;
            margin-bottom: 10px;
        }

        .control-button:hover {
            background-color: rgba(255, 255, 255, 0.2);
        }

        select {
            width: 100%;
            padding: 6px;
            margin: 5px 0;
            background: black;
            color: white;
            border: none;
            border-radius: 8px;
        }
        .section {
            opacity: 1;
            visibility: visible;
            transition: opacity 0.5s ease, visibility 0.5s ease;
        }

        .hidden-content {
            opacity: 0;
            pointer-events: none;
        }
        #about {
            margin-top: 200px;
            padding-top: 0px;
            position: relative;
        }
        .about-container {
            display: flex;
            align-items: center;
            gap: 20px;
        }

        .photo-frame {
            width: 150px;
            height: 200px;
            border: 5px solid #ffc500;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }

        .photo-frame img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .about-content {
            flex: 1; /* Allow the text to take up the remaining space */
        }
        .research-project {
            margin-top: 20px; /* Add spacing between projects */
            padding: 10px 15px;
            background-color: rgba(0, 0, 0, 0.6); /* Semi-transparent background */
            border-left: 4px solid #ffc500; /* Highlight each project */
            border-radius: 5px; /* Rounded corners */
        }
        .research-project h4 {
            margin-bottom: 10px;
            color: #ffc500;
        }
        .research-project p {
            margin: 0;
            line-height: 1.6;
        }
        .photo-frame-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }

        .photo-frame {
            width: 150px;
            height: 200px;
            border: 2px solid #ffc500; /* Gold border for the frame */
            border-radius: 5px; /* Rounded corners */
            overflow: hidden; /* Ensures the photo stays inside the frame */
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2); /* Optional: Add a shadow for depth */
        }

        .photo-frame img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        .research-container {
            display: flex;
            align-items: center;
            gap: 20px;
            margin-top: 10px;
            margin-bottom: 10px;
        }

        .research-photo {
            width: 150px;
            height: 150px;
            flex-shrink: 0;
            overflow: hidden;
            border-radius: 2px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }

        .research-photo img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .research-text {
            flex: 1;
        }

        .research-text h4 {
            color: #ffc500;
            margin-bottom: 10px;
        }

        .research-text p {
            line-height: 1.6;
        }

        .contact-icons {
            display: flex;
            justify-content: center;
            gap: 15px;
        }

        .contact-icons a {
            color: #ffc500;
            font-size: 20px;
            text-decoration: none;
            transition: color 0.3s ease, transform 0.3s ease;
        }

        .contact-icons a:hover {
            color: #1eceff;
            transform: scale(1.2);
        }
        .fish-toggle {
            margin-left: auto;
            display: flex;
            align-items: center;
            padding-right: 20px;
            padding-top: 5px;
        }

        #fishToggle {
            height: 45px;
            width: auto;
            cursor: pointer;
            transition: transform 0.3s ease;
        }

        #fishToggle:hover {
            transform: scale(1.2);
        }
        a {
            color: #1eceff;
            text-decoration: none;
        }

        a:hover {
            text-decoration: underline;
        }
        @media screen and (max-width: 767px) {
            #top-menu {
                left: 0;
                right: 0;
                border-radius: 0;
                justify-content: space-around;
                padding: 0 10px;
            }

            #top-menu .nav-link {
                font-size: 16px;
                margin: 0 8px;
            }

            .fish-toggle {
                margin-left: 10px;
                padding-right: 10px;
            }

            #fishToggle {
                height: 35px;
            }

            .section {
                margin-left: 20px;
                margin-right: 20px;
            }

            #about {
                margin-top: 100px;
            }

            canvas {
                top: 60px;
            }

            .header-title {
                font-size: 16px;
            }

            .section h3 {
                font-size: 12px;
                margin-bottom: 10px;
            }

            .section h4 {
                font-size: 10px;
                margin-bottom: 10px;
            }

            .section p, 
            .section ul {
                font-size: 10px;
                line-height: 1.6;
            }

            .about-content p {
                font-size: 10px;
                line-height: 1.6;
            }

            .research-text h4 {
                font-size: 12px;
            }

            .research-text p {
                font-size: 10px;
                line-height: 1.6;
            }

            .contact-icons a {
                font-size: 12px;
            }

            .research-photo {
                width: 120px;
                height: 120px;
            }

            #controls-panel h3 {
                font-size: 16px;
            }

            #controls-panel p {
                font-size: 12px;
            }

            .control-button {
                font-size: 12px;
                padding: 6px 10px;
            }

            select {
                font-size: 12px;
                padding: 4px;
            }

            #fishCount {
                font-size: 12px;
            }
        }
    </style>
</head>

<body>
    <div id="top-menu">
        <a class="nav-link" href="javascript:void(0)" onclick="scrollToSection('about')">About</a>
        <a class="nav-link" href="javascript:void(0)" onclick="scrollToSection('research')">Research</a>
        <a class="nav-link" href="javascript:void(0)" onclick="scrollToSection('contact')">Contact Info</a>
        <div class="fish-toggle">
            <img src="images/fishon.png" alt="Toggle Fish" id="fishToggle" title="Turn on fish tank" onclick="toggleFish()" />
        </div>
    </div>
    <div id="controls-panel">
        <h3>Fish Tank Controls</h3>
        <button class="control-button" onclick="toggleDayNight()">🌙/🌞 Mode</button>
        <select id="fishSelector">
            <option value="minnow">Minnow</option>
            <option value="bluegill">Bluegill</option>
            <option value="crappie">Crappie</option>
            <option value="perch">Perch</option>
            <option value="guppy">Guppy</option>
            <option value="tetra">Tetra</option>
            <option value="zebra">Zebrafish</option>
            <option value="goldfish">Goldfish</option>
            <option value="herring">Herring</option>
            <option value="trout">Brown Trout</option>
            <option value="salmon">Salmon</option>
            <option value="salmon2">White Salmon</option>
            <option value="walleye">Walleye</option>
            <option value="spotted">Spotted Bass</option>
            <option value="smallmouth">Smallmouth Bass</option>
            <option value="largemouth">Largemouth Bass</option>
            <option value="pike">Northern Pike</option>
            <option value="crucian">Crucian Carp</option>
            <option value="carp">Common Carp</option>
            <option value="ghost">Ghost Carp</option>
            <option value="carp2">Leather Carp</option>
            <option value="koi">Koi Carp</option>
            <option value="bullhead">Bullhead Catfish</option>
            <option value="channel">Channel Catfish</option>
            <option value="flathead">Flathead Catfish</option>
            <option value="catfish">Blue Catfish</option>
            <option value="sturgeon">Lake Sturgeon</option>
            <option value="beluga">Beluga</option>
        </select>
        <button class="control-button" onclick="addSelectedFish()">Add Fish</button>
        <button class="control-button" onclick="toggleAutoFeed()">Disable Auto Feed</button>
        <button class="control-button" onclick="dropFood()">Feed Pellets</button>
        <button class="control-button" onclick="clearFishTank()">Clear Tank</button>
        <button class="control-button" onclick="toggleAnimation()">Pause/Play</button>
        <button class="control-button" onclick="togglePageContent()">Hide Home Page Content</button>
        <h3>Fish Count</h3>
        <p id="fishCount">Total Fish: 0</p> <!-- Fish count display -->
    </div>

    <button id="toggle-controls"></button>

    <h1 class="header-title"></h1>

    <section id="about" class="section">
        <div class="about-container">
            <div class="photo-frame-container">
                <div class="photo-frame">
                    <img src="images/jianghui-li.jpg" alt="My Photo">
                </div>
                <div class="contact-icons">
                    <a href="mailto:jli159@syr.edu" target="_blank" title="Email">
                        <i class="fas fa-envelope"></i>
                    </a>
                    <a href="https://github.com/Jianghui-Li" target="_blank" title="GitHub">
                        <i class="fab fa-github"></i>
                    </a>
                    <a href="https://www.linkedin.com/in/jianghui-li-9804/" target="_blank" title="LinkedIn">
                        <i class="fab fa-linkedin"></i>
                    </a>
                    <a href="files/jianghui-li-cv.pdf" target="_blank" title="View CV">
                        <i class="fas fa-file-alt"></i>
                    </a>
                </div>
            </div>
            <div class="about-content">
                <h3>About me</h3>
                <p>Hello👋! My name is Jianghui Li, and I am a Master's student at the iSchool of Syracuse University. I am interested in researching how interactions within sociotechnical systems such as collaborative platforms and social media shape individual and collective decision-making, behaviors, and responses to various challenges. 
                    I use computational methods such as machine learning, natural language processing, and inferential statistics, alongside qualitative methods, drawing on insights from ecology and complex adaptive systems to guide my research. 
                    </p>
            </div>
        </div>
    </section>
    

    <section id="research" class="section">
        <h3>Research</h3>
        <div class="research-project">
            <div class="research-container">
                <div class="research-photo">
                    <img src="images/r-att.png" alt="Belief Dynamics Research" />
                </div>
                <div class="research-text">
                    <h4>Predicting Belief Dynamics</h4>
                    <p>
                        This project focuses on predicting individual belief stability across various discourses including climate change, cross-cultural, political, and AI on social media platforms. While existing 
                        works focus on modeling and analyzing population-level belief shifts, this work includes individual stability by building on <a href="https://ojs.aaai.org/index.php/ICWSM/article/view/22154/21933" target="_blank">the belief landscape model</a> with new computational methods.
                        The on-going work is presented at the ACM Collective Intelligence (CI’24) and 10th International Conference on Computational Social Science (IC2S2). 
                        <a href="files/CI24_paper.pdf" target="_blank">The extended abstract</a> and <a href="files/ic2s2-poster-jianghui-li.pdf" target="_blank">the poster</a> are available. 
                    </p>
                </div>
            </div>
        </div>
        
        <div class="research-project">
            <div class="research-container">
                <div class="research-photo">
                    <img src="images/r-art.png" alt="AI Art Debate" />
                </div>
                <div class="research-text">
                    <h4>AI Art Debate</h4>
                    <p>
                        This research examines public debates around image-generative AI. This study uncovered potential themes for AI art 
                        debate in natural settings using data collected from Reddit. We also performed a longitudinal analysis on how these themes change over time. 
                        We found that themes tend to gain traction from external events aligned with each theme’s focus, while internal factors within the discussion community, 
                        such as recurring arguments or influential posts, also play a significant role in driving engagement. Our work is accepted by the 58th Annual Hawaii International Conference on System Sciences (HICSS-58). 
                        <a href="files/HICSS25.pdf" target="_blank">The full paper is available</a>.
                    </p>
                </div>
            </div>
        </div>
    </section>
    

    <section id="contact" class="section">
        <h3>Contact Info</h3>
        <p>If you'd like to collaborate or learn more, feel free to reach out:</p>
        <ul style="list-style: none; padding: 0;">
            <li>
                <a href="mailto:jli159@syr.edu" target="_blank" style="color: #ffc500; text-decoration: none;">
                    <i class="fas fa-envelope"></i> jli159@syr.edu
                </a>
            </li>
            <li>
                <a href="https://github.com/Jianghui-Li" target="_blank" style="color: #ffc500; text-decoration: none;">
                    <i class="fab fa-github"></i> GitHub: github.com/Jianghui-Li
                </a>
            </li>
            <li>
                <a href="https://www.linkedin.com/in/jianghui-li-9804/" target="_blank" style="color: #ffc500; text-decoration: none;">
                    <i class="fab fa-linkedin"></i> LinkedIn: linkedin.com/in/jianghui-li-9804/
                </a>
            </li>
        </ul>
    </section>
    
    <canvas id="background"></canvas>
    <div id="click-overlay"></div>

    <script>
        const canvas = document.getElementById("background");
        const ctx = canvas.getContext("2d");
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        function scrollToSection(sectionId) {
            const section = document.getElementById(sectionId);
            if (section) {
                const topMenuHeight = document.getElementById('top-menu').offsetHeight;
                const extraSpacing = 50;
                const sectionTop = section.offsetTop - topMenuHeight - extraSpacing;

                window.scrollTo({
                    top: sectionTop,
                    behavior: 'smooth',
                });
            }
        }

        function togglePageContent() {
            const pageContent = document.querySelectorAll('.section, #top-menu');
            const isHidden = document.querySelector('.section').classList.contains('hidden-content');
            
            pageContent.forEach((element) => {
                element.classList.toggle('hidden-content');
            });
            const toggleButton = document.querySelector('.control-button[onclick="togglePageContent()"]');
            toggleButton.textContent = isHidden ? "Hide Home Page Content" : "Show Home Page Content";
        }

        const toggleButton = document.getElementById('toggle-controls');
        const controlsPanel = document.getElementById('controls-panel');
        toggleButton.addEventListener('click', () => {
            controlsPanel.classList.toggle('active');
            toggleButton.classList.toggle('active');
        });

        const overlay = document.getElementById('click-overlay');

        overlay.addEventListener('click', (event) => {
            const rect = canvas.getBoundingClientRect();
            spookCenter = {
                x: event.clientX - rect.left,
                y: event.clientY - rect.top
            };
            spookStartTime = Date.now();
        });

        function initializeFish() {
            if (fishActive) {
                clearFishTank(); // Clear existing fish first
            }
            
            // Reset all animation and speed related variables
            globalSpeedMultiplier = 1;
            animationActive = true;
            fishActive = true;
            
            const useAlternative = Math.random() < 0.5;
            const initialFishCounts = useAlternative
                ? {
                    perch: 22,
                    bluegill: 18,
                    crappie: 18,
                    largemouth: 2,
                    smallmouth: 2,
                    walleye: 2,
                    pike: 2,
                    bullhead: 6
                }
                : {
                    guppy: 15,
                    tetra: 20,
                    zebra: 15,
                    goldfish: 12,
                    koi: 4,
                    ghost: 6
                };

            for (const [type, count] of Object.entries(initialFishCounts)) {
                for (let i = 0; i < count; i++) {
                    fishArray.push(new Fish(type, true));
                }
            }
            
            updateFishCount();
            
            // Start animation only if fish are active
            if (fishActive) {
                animate();
            }
        }
        let fishActive = false;
        let animationFrameId = null;
        function toggleFish() {
            const toggleImg = document.getElementById('fishToggle');
            
            if (!fishActive) {
                // Turn fish on
                fishActive = true;
                animationActive = true;
                initializeFish();
                toggleImg.src = 'images/fishoff.png';
                toggleImg.title = "Turn off fish tank";
                
                // Update pause/play button state
                const toggleButton = document.querySelector('.control-button[onclick="toggleAnimation()"]');
                if (toggleButton) {
                    toggleButton.textContent = "Currently Playing";
                }
                
                // Enable auto-feed when adding fish
                autoFeedEnabled = true;
                const toggleFeedButton = document.querySelector('.control-button[onclick="toggleAutoFeed()"]');
                if (toggleFeedButton) {
                    toggleFeedButton.textContent = "Disable Auto Feed";
                }
                scheduleRandomFoodDrop(); // Start auto-feeding
            } else {
                // Turn fish off
                clearFishTank();
                toggleImg.src = 'images/fishon.png';
                toggleImg.title = "Turn on fish tank";
                
                // Disable auto-feed when clearing fish
                autoFeedEnabled = false;
                const toggleFeedButton = document.querySelector('.control-button[onclick="toggleAutoFeed()"]');
                if (toggleFeedButton) {
                    toggleFeedButton.textContent = "Enable Auto Feed";
                }
                clearTimeout(autoFeedTimeout); // Clear any pending auto-feed
            }
        }
        const fishSpecies = {
            sturgeon: { minSize: 90, maxSize: 220, defaultAngle: -Math.PI / 2, depthPreference: 'bottom', bottomBias: 0.8 },
            beluga: { minSize: 120, maxSize: 280, defaultAngle: -Math.PI / 2, depthPreference: 'bottom', bottomBias: 0.8 },
            pike: { minSize: 50, maxSize: 120, defaultAngle: -Math.PI / 2, depthPreference: 'top', depthBias: 0.6 },
            largemouth: { minSize: 35, maxSize: 80, defaultAngle: -Math.PI / 2},
            smallmouth: { minSize: 35, maxSize: 70, defaultAngle: -Math.PI / 2},
            spotted: { minSize: 35, maxSize: 65, defaultAngle: -Math.PI / 2},
            carp: { minSize: 45, maxSize: 110, defaultAngle: -Math.PI / 2},
            ghost: { minSize: 40, maxSize: 110, defaultAngle: -Math.PI / 2, variants: ['ghost', 'ghost-1', 'ghost-2', 'ghost-3']},
            carp2: { minSize: 50, maxSize: 130, defaultAngle: -Math.PI / 2},
            koi: { minSize: 40, maxSize: 110, defaultAngle: -Math.PI / 2, variants: ['koi', 'koi-1', 'koi-2', 'koi-3'] },
            crucian: { minSize: 20, maxSize: 40, defaultAngle: -Math.PI / 2},
            catfish: { minSize: 65, maxSize: 160, defaultAngle: -Math.PI / 2, depthPreference: 'bottom', bottomBias: 0.9 },
            flathead: { minSize: 60, maxSize: 140, defaultAngle: -Math.PI / 2, depthPreference: 'bottom', bottomBias: 0.9 },
            channel: { minSize: 40, maxSize: 100, defaultAngle: -Math.PI / 2, depthPreference: 'bottom', bottomBias: 0.9 },
            bullhead: { minSize: 20, maxSize: 50, defaultAngle: -Math.PI / 2, depthPreference: 'bottom', bottomBias: 0.9 },
            trout: { minSize: 35, maxSize: 80, defaultAngle: -Math.PI / 2, depthPreference: 'top', depthBias: 0.7 },
            salmon: { minSize: 60, maxSize: 130, defaultAngle: -Math.PI / 2, depthPreference: 'top', depthBias: 0.7 },
            salmon2: { minSize: 50, maxSize: 110, defaultAngle: -Math.PI / 2, depthPreference: 'top', depthBias: 0.7 },
            herring: { minSize: 12, maxSize: 30, defaultAngle: -Math.PI / 2, depthPreference: 'top', depthBias: 0.7 },
            walleye: { minSize: 40, maxSize: 80, defaultAngle: -Math.PI / 2},
            crappie: { minSize: 20, maxSize: 40, defaultAngle: -Math.PI / 2},
            bluegill: { minSize: 12, maxSize: 30, defaultAngle: -Math.PI / 2},
            perch: { minSize: 15, maxSize: 35, defaultAngle: -Math.PI / 2},
            goldfish: { minSize: 15, maxSize: 35, defaultAngle: -Math.PI / 2, variants: ['goldfish', 'goldfish-1', 'goldfish-2', 'goldfish-3']},
            guppy: { minSize: 6, maxSize: 18, defaultAngle: -Math.PI / 2},
            tetra: { minSize: 8, maxSize: 20, defaultAngle: -Math.PI / 2},
            zebra: { minSize: 6, maxSize: 18, defaultAngle: -Math.PI / 2},
            minnow: { minSize: 10, maxSize: 25, defaultAngle: -Math.PI / 2}
        };
        function updateFishCount() {
            const fishCountElement = document.getElementById('fishCount');
            fishCountElement.textContent = `Total Fish: ${fishArray.length}`;
            
            // Control auto-feed based on fish count
            if (fishArray.length === 0) {
                // Disable auto-feed if no fish
                const toggleButton = document.querySelector('.control-button[onclick="toggleAutoFeed()"]');
                if (toggleButton && autoFeedEnabled) {
                    autoFeedEnabled = false;
                    toggleButton.textContent = "Enable Auto Feed";
                    clearTimeout(autoFeedTimeout);  // Clear any pending auto-feed
                }
            }
        }
        function addSelectedFish() {
            if (!fishActive) {
                fishActive = true;
                animationActive = true;
                const toggleImg = document.getElementById('fishToggle');
                if (toggleImg) {
                    toggleImg.src = 'images/fishoff.png';
                }
                
                // Update pause/play button state
                const toggleButton = document.querySelector('.control-button[onclick="toggleAnimation()"]');
                if (toggleButton) {
                    toggleButton.textContent = "Currently Playing";
                }
                
                animate(); // Restart animation
            }

            const selector = document.getElementById('fishSelector');
            const type = selector.value;
            const newFish = new Fish(type);
            newFish.y = -newFish.size; // Start from top
            fishArray.push(newFish);
            updateFishCount();
        }

        const fishLifeSpans = {
            beluga: { min: 540000, max: 900000 },
            sturgeon: { min: 480000, max: 780000 },
            pike: { min: 240000, max: 480000 },
            largemouth: { min: 240000, max: 420000 },
            smallmouth: { min: 240000, max: 420000 },
            spotted: { min: 240000, max: 420000 },
            carp: { min: 300000, max: 480000 },
            ghost: { min: 300000, max: 480000 },
            carp2: { min: 300000, max: 480000 },
            koi: { min: 300000, max: 540000 },
            crucian: { min: 240000, max: 420000 },
            catfish: { min: 300000, max: 480000 },
            flathead: { min: 300000, max: 480000 },
            channel: { min: 300000, max: 480000 },
            bullhead: { min: 240000, max: 420000 },
            trout: { min: 240000, max: 420000 },
            salmon: { min: 240000, max: 420000 },
            salmon2: { min: 240000, max: 420000 },
            herring: { min: 240000, max: 360000 },
            walleye: { min: 240000, max: 420000 },
            crappie: { min: 200000, max: 360000 },
            bluegill: { min: 200000, max: 360000 },
            perch: { min: 200000, max: 360000 },
            goldfish: { min: 180000, max: 420000 },
            guppy: { min: 150000, max: 280000 },
            tetra: { min: 180000, max: 360000 },
            zebra: { min: 160000, max: 320000 },
            minnow: { min: 150000, max: 300000 }
        };
        class FoodPellet {
            constructor(x) {
                this.x = x || Math.random() * canvas.width;
                this.y = 0;
                this.size = 1;
                this.speed = 0.5 + Math.random() * 0.5;
                this.consumed = false;

                const colors = ['#FFD700', '#00FF00', '#FF0000'];
                this.color = colors[Math.floor(Math.random() * colors.length)];
            }

            update() {
                if (!this.consumed) {
                    this.y += this.speed;
                    return this.y < canvas.height;
                }
                return false;
            }

            draw() {
                if (!this.consumed) {
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                    ctx.fillStyle = this.color;
                    ctx.fill();
                }
            }
        }

        const fishImages = {};
        let fishLoaded = 0;

        const foodPellets = [];

        function clearFishTank() {
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }

            while (fishArray.length > 0) {
                fishArray.pop();
            }
            while (foodPellets.length > 0) {
                foodPellets.pop();
            }

            fishActive = false;
            globalSpeedMultiplier = 1;
            
            // Draw the background without affecting surface lights
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            if (!isDarkMode) {
                let gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
                gradient.addColorStop(0, 'rgba(0, 75, 65, 0.9)');
                gradient.addColorStop(0.5, 'rgba(0, 45, 40, 0.95)');
                gradient.addColorStop(1, 'rgba(0, 25, 20, 0.98)');
                
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Continue animating existing surface lights
                function animateExistingSurfaceLights() {
                    if (!fishActive && !isDarkMode) {
                        ctx.clearRect(0, 0, canvas.width, canvas.height);
                        
                        // Redraw gradient background
                        ctx.fillStyle = gradient;
                        ctx.fillRect(0, 0, canvas.width, canvas.height);
                        
                        // Animate existing surface lights without reinitializing
                        surfaceLights.forEach(light => {
                            light.x += light.speed;
                            if (light.x > canvas.width + light.width) {
                                light.x = -light.width;
                            }

                            let beamGradient = ctx.createRadialGradient(
                                light.x, 0, 0,
                                light.x, 0, light.width
                            );
                            
                            beamGradient.addColorStop(0, `rgba(255, 250, 240, ${light.intensity * 0.2})`);
                            beamGradient.addColorStop(0.5, `rgba(240, 240, 230, ${light.intensity * 0.1})`);
                            beamGradient.addColorStop(1, 'rgba(255, 255, 255, 0)');

                            ctx.fillStyle = beamGradient;
                            
                            ctx.beginPath();
                            ctx.moveTo(light.x - light.width/2, 0);
                            ctx.lineTo(light.x + light.width/2, 0);
                            ctx.lineTo(light.x + light.width, canvas.height);
                            ctx.lineTo(light.x - light.width, canvas.height);
                            ctx.closePath();
                            ctx.fill();
                        });
                        
                        requestAnimationFrame(animateExistingSurfaceLights);
                    }
                }
                
                // Only start surface light animation if it's not already running
                if (!animationFrameId) {
                    animateExistingSurfaceLights();
                }
            } else {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }
            
            updateFishCount();
        }

        function addNewFish(type) {
            const newFish = new Fish(type, false);
            newFish.y = -newFish.size; // Start from top
            fishArray.push(newFish);
        }

        window.onload = function() {
            // Initialize with fish off
            const toggleImg = document.getElementById('fishToggle');
            toggleImg.src = 'images/fishon.png';
            fishActive = false;

            const useAlternative = Math.random() < 0.5;
            const initialFishCounts = useAlternative
                ? {
                    perch: 24,
                    bluegill: 20,
                    crappie: 12,
                    largemouth: 2,
                    smallmouth: 2,
                    walleye: 2,
                    pike: 2,
                    bullhead: 6
                }
                : {
                    guppy: 15,
                    tetra: 20,
                    zebra: 15,
                    goldfish: 12,
                    koi: 8,
                    ghost: 6
                };

            for (const [type, count] of Object.entries(initialFishCounts)) {
                for (let i = 0; i < count; i++) {
                    fishArray.push(new Fish(type, true));
                }
            }

            updateFishCount();
            animate();
        };
        function removeFish(fish) {
            const index = fishArray.indexOf(fish);
            if (index > -1) {
                fishArray.splice(index, 1);
                updateFishCount();
            }
        }
        function dropFood() {
            // If tank is inactive but we try to feed, reactivate it
            if (!fishActive) {
                fishActive = true;
                animationActive = true;
                const toggleImg = document.getElementById('fishToggle');
                if (toggleImg) {
                    toggleImg.src = 'images/fishoff.png';
                }
                animate(); // Restart animation
            }

            // Now proceed with food dropping
            const fishCount = fishArray.length;
            const pelletCount = Math.min(10 + Math.floor(fishCount / 2), 80);

            for (let i = 0; i < pelletCount; i++) {
                const mean = canvas.width / 2;
                const standardDeviation = canvas.width / 6;
                const x = generateGaussian(mean, standardDeviation);
                const boundedX = Math.max(0, Math.min(canvas.width - 50, x));
                foodPellets.push(new FoodPellet(boundedX));
            }

            console.log(`Dropped ${pelletCount} food pellets for ${fishCount} fish.`);
        }

        function generateGaussian(mean, standardDeviation) {
            let u1 = Math.random();
            let u2 = Math.random();
            let randStdNormal = Math.sqrt(-2.0 * Math.log(u1)) * Math.sin(2.0 * Math.PI * u2); // Random normal (0,1)
            return mean + standardDeviation * randStdNormal; // Adjusted for desired mean and standard deviation
        }
        function scheduleRandomFoodDrop() {
            if (!autoFeedEnabled) return;
            // Only schedule next drop if there are fish
            if (fishArray.length > 0) {
                const randomInterval = Math.floor(Math.random() * 20000) + 10000;
                autoFeedTimeout = setTimeout(() => {
                    if (fishArray.length > 0) {  // Double-check before dropping
                        dropFood();
                    }
                    scheduleRandomFoodDrop(); // Schedule next drop
                }, randomInterval);
            }
        }

        let autoFeedEnabled = true;

        function toggleAutoFeed() {
            if (!autoFeedEnabled && fishArray.length === 0) {
                console.log("Cannot enable auto-feed without fish");
                return;  // Prevent enabling auto-feed when no fish
            }

            autoFeedEnabled = !autoFeedEnabled;
            const toggleButton = document.querySelector('.control-button[onclick="toggleAutoFeed()"]');
            toggleButton.textContent = autoFeedEnabled ? "Disable Auto Feed" : "Enable Auto Feed";

            if (!autoFeedEnabled) {
                clearTimeout(autoFeedTimeout);
            } else {
                scheduleRandomFoodDrop();
            }
        }

        // Variable to store the timeout ID for scheduled food drops
        let autoFeedTimeout;

        function scheduleRandomFoodDrop() {
            if (!autoFeedEnabled) return; // Exit if autofeed is disabled

            const randomInterval = Math.floor(Math.random() * 20000) + 10000; // Random interval between 10-20 seconds
            autoFeedTimeout = setTimeout(() => {
                dropFood();
                scheduleRandomFoodDrop(); // Schedule the next drop
            }, randomInterval);
        }
        scheduleRandomFoodDrop();

        // Modify the image loading section to not auto-initialize
        const totalImagesToLoad = Object.keys(fishSpecies).length + 9;

        // Load regular fish images without auto-initialization
        Object.keys(fishSpecies).forEach(type => {
            if (type !== 'goldfish' && type !== 'koi'&& type !== 'ghost') {
                const img = new Image();
                img.src = `images/${type}.png`;
                img.onload = () => {
                    fishLoaded++;
                    console.log(`Loaded ${type}.png`);
                    fishImages[type] = img;
                    // Don't initialize on load completion
                };
                img.onerror = () => {
                    console.error(`Failed to load ${type}.png`);
                };
            }
        });

        ['goldfish', 'goldfish-1', 'goldfish-2', 'goldfish-3'].forEach(variant => {
            const img = new Image();
            img.src = `images/${variant}.png`;
            img.onload = () => {
                fishLoaded++;
                console.log(`Loaded ${variant}.png`);
                fishImages[variant] = img;
                // Don't initialize on load completion
            };
            img.onerror = () => {
                console.error(`Failed to load ${variant}.png`);
            };
        });

        ['koi', 'koi-1', 'koi-2', 'koi-3'].forEach(variant => {
            const img = new Image();
            img.src = `images/${variant}.png`;
            img.onload = () => {
                fishLoaded++;
                console.log(`Loaded ${variant}.png`);
                fishImages[variant] = img;
                // Don't initialize on load completion
            };
            img.onerror = () => {
                console.error(`Failed to load ${variant}.png`);
            };
        });
        ['ghost', 'ghost-1', 'ghost-2', 'ghost-3'].forEach(variant => {
            const img = new Image();
            img.src = `images/${variant}.png`;
            img.onload = () => {
                fishLoaded++;
                console.log(`Loaded ${variant}.png`);
                fishImages[variant] = img;
                // Don't initialize on load completion
            };
            img.onerror = () => {
                console.error(`Failed to load ${variant}.png`);
            };
        });

        // Add window load event to ensure proper initial state
        window.addEventListener('load', () => {
            const toggleImg = document.getElementById('fishToggle');
            if (toggleImg) {
                toggleImg.src = 'images/fishon.png';
            }
            fishActive = false;
            clearFishTank(); // Ensure clean initial state
        });

        const fishArray = [];
        let animationActive = true;
        let globalSpeedMultiplier = 1;

        function checkRandomDeaths() {
            const fishCount = fishArray.length;
            let deathChance = 0;

            if (fishCount > 400) {
                deathChance = 0.015;
            } else if (fishCount > 325) {
                deathChance = 0.008;
            } else if (fishCount > 250) {
                deathChance = 0.004;
            } else if (fishCount > 150) {
                deathChance = 0.002;
            }

            if (deathChance > 0) {
                fishArray.forEach((fish, index) => {
                    if (fish.isAlive) {
                        const effectiveDeathChance = fish.isAdult ? deathChance / 3 : deathChance;
                        if (Math.random() < effectiveDeathChance) {
                            fish.isAlive = false;
                            fish.causeOfDeath = 'random'; // Use "random" as cause of death
                            fish.rotationForDeath = 0; // Initialize rotation for death animation
                            fish.opacity = 1.0; // Reset opacity for fade-out animation
                        }
                    }
                });
                updateFishCount(); // Update the displayed count
            }
        }

        // Call checkRandomDeaths every second
        setInterval(checkRandomDeaths, 1000);

        const fishBehavior = {
            beluga: { isSchooling: false, isPredator: true, schoolSize: 0, preyTypes: [] },
            sturgeon: { isSchooling: false, isPredator: true, schoolSize: 0, preyTypes: [] },
            pike: { isSchooling: true, isPredator: true, schoolSize: 5, preyTypes: ['minnow', 'crappie','guppy','goldfish','tetra','perch','bluegill','zebra','crucian'] },
            largemouth: { isSchooling: true, isPredator: true, schoolSize: 5, preyTypes: ['minnow', 'crappie','guppy','goldfish','tetra','perch','bluegill','zebra','crucian'] },
            smallmouth: { isSchooling: true, isPredator: true, schoolSize: 5, preyTypes: ['minnow', 'crappie','guppy','goldfish','tetra','perch','bluegill','zebra','crucian'] },
            spotted: { isSchooling: true, isPredator: true, schoolSize: 5, preyTypes: ['minnow', 'crappie','guppy','goldfish','tetra','perch','bluegill','zebra','crucian'] },
            carp: { isSchooling: true, isPredator: false, schoolSize: 6, preyTypes: [] },
            ghost: { isSchooling: true, isPredator: false, schoolSize: 6, preyTypes: [] },
            carp2: { isSchooling: true, isPredator: false, schoolSize: 6, preyTypes: [] },
            koi: { isSchooling: true, isPredator: false, schoolSize: 6, preyTypes: [] },
            crucian: { isSchooling: true, isPredator: false, schoolSize: 10, preyTypes: [] },
            catfish: { isSchooling: false, isPredator: true, schoolSize: 0, preyTypes: ['minnow', 'crappie','guppy','goldfish','tetra','perch','bluegill','zebra','crucian'] },
            flathead: { isSchooling: false, isPredator: true, schoolSize: 0, preyTypes: ['minnow', 'crappie','guppy','goldfish','tetra','perch','bluegill','zebra','crucian'] },
            channel: { isSchooling: false, isPredator: true, schoolSize: 0, preyTypes: ['minnow', 'crappie','guppy','goldfish','tetra','perch','bluegill','zebra','crucian'] },
            bullhead: { isSchooling: true, isPredator: true, schoolSize: 10, preyTypes: ['minnow','guppy','tetra','zebra'] },
            trout: { isSchooling: true, isPredator: true, schoolSize: 6, preyTypes: ['minnow','guppy','tetra','zebra'] },
            salmon: { isSchooling: true, isPredator: true, schoolSize: 6, preyTypes: ['minnow','guppy','tetra','zebra'] },
            salmon2: { isSchooling: true, isPredator: true, schoolSize: 6, preyTypes: ['minnow','guppy','tetra','zebra'] },
            herring: { isSchooling: true, isPredator: true, schoolSize: 20, preyTypes: [] },
            walleye: { isSchooling: true, isPredator: true, schoolSize: 5, preyTypes: ['minnow','guppy','tetra','perch','bluegill','zebra'] },
            crappie: { isSchooling: true, isPredator: true, schoolSize: 15, preyTypes: [] },
            bluegill: { isSchooling: true, isPredator: true, schoolSize: 15, preyTypes: [] },
            perch: { isSchooling: true, isPredator: true, schoolSize: 15, preyTypes: [] },
            goldfish: { isSchooling: true, isPredator: false, schoolSize: 15, preyTypes: [] },
            guppy: { isSchooling: true, isPredator: false, schoolSize: 30, preyTypes: [] },
            tetra: { isSchooling: true, isPredator: false, schoolSize: 30, preyTypes: [] },
            zebra: { isSchooling: true, isPredator: false, schoolSize: 30, preyTypes: [] },
            minnow: { isSchooling: true, isPredator: false, schoolSize: 30, preyTypes: [] }
        };
        const fishSpeedFactors = {
            beluga: 0.8,
            sturgeon: 0.8,
            pike: 1.1,
            largemouth: 1,
            smallmouth: 1.1,
            spotted: 1.1,
            carp: 0.9,
            ghost: 0.9,
            carp2: 0.8,
            koi: 0.9,
            crucian: 0.7,
            catfish: 0.8,
            flathead: 0.8,
            channel: 0.8,
            bullhead: 0.8,
            trout: 1.1,
            salmon: 1.1,
            salmon2: 1.1,
            herring: 0.9,
            walleye: 1,
            crappie: 0.7,
            bluegill: 0.7,
            perch: 0.7,
            goldfish: 0.7,
            guppy: 0.7,
            tetra: 0.7,
            zebra: 0.7,
            minnow: 0.7
        };
        const reproductionDelayMultiplier = {
            beluga: 2.5,
            sturgeon: 2,
            pike: 1.2,
            largemouth: 1.1,
            smallmouth: 1.1,
            spotted: 1.1,
            carp: 1.1,
            ghost: 1.2,
            carp2: 1.1,
            koi: 1.2,
            crucian: 0.9,
            catfish: 1,
            flathead: 1,
            channel: 1,
            bullhead: 1,
            trout: 1,
            salmon: 1,
            salmon2: 1,
            herring: 0.8,
            walleye: 1.1,
            crappie: 0.9,
            bluegill: 0.8,
            perch: 0.8,
            goldfish: 1,
            guppy: 0.7,
            tetra: 0.8,
            zebra: 0.9,
            minnow: 0.8
        };
        // Define an attractor for the school (global attractor variable)
        let attractorCenter = { x: Math.random() * canvas.width, y: Math.random() * canvas.height };
        let attractorChangeTime = Date.now() + 10000 + Math.random() * 10000; // Change attractor every 10-20 seconds

        function updateAttractor() {
            const now = Date.now();
            if (now > attractorChangeTime) {
                attractorCenter = { 
                    x: Math.random() * canvas.width, 
                    y: Math.random() * canvas.height 
                };
                attractorChangeTime = now + 10000 + Math.random() * 10000; // Change again in 10-20 seconds
            }
        }
        let spookCenter = null;
        let spookRadius = 150; // Area of effect
        let spookDuration = 1500; // Duration in milliseconds
        let spookStartTime = 0;

        // Add click event listener
        canvas.addEventListener('click', (event) => {
            const rect = canvas.getBoundingClientRect();
            spookCenter = {
                x: event.clientX - rect.left,
                y: event.clientY - rect.top
            };
            spookStartTime = Date.now();
        });
        class Fish {
            constructor(type, isInitial = true, isOffspring = false, parentVariant = null) {
                if (type === 'goldfish' || type === 'koi'|| type === 'ghost') {
                    if (parentVariant) {
                        this.variant = parentVariant;
                    } else if (isOffspring) {
                        // For offspring, randomly select from available variants in the tank
                        const availableVariants = this.getAvailableVariants(type);
                        this.variant = availableVariants[Math.floor(Math.random() * availableVariants.length)];
                    } else {
                        // For initial or new fish, randomly select from all variants
                        const variants = fishSpecies[type].variants;
                        this.variant = variants[Math.floor(Math.random() * variants.length)];
                    }
                }
                this.type = type;
                this.behavior = fishBehavior[type];
                this.size = this.getRandomSize();
                this.isInitial = isInitial;
                this.isAlive = true;
                const sizeSpeedFactor = Math.sqrt(fishSpecies[type].minSize / this.size);
                const speciesSpeedFactor = fishSpeedFactors[type];
                this.baseSpeed = 2 * sizeSpeedFactor * speciesSpeedFactor;
                this.speed = this.baseSpeed;
                this.schoolCenter = { x: 0, y: 0 };
                this.fleeingFrom = null;
                this.opacity = 1.0;
                this.rotationForDeath = 0;
                this.reset();

                // Hunger system
                this.maxHunger = 100;
                this.hunger = 80;
                this.hungerRate = 0.01;
                this.lastMealTime = Date.now();
                
                // Other properties
                this.birthTime = Date.now();
                const lifespanRange = fishLifeSpans[type];
                this.lifeSpan = Math.random() * (lifespanRange.max - lifespanRange.min) + lifespanRange.min;
                if (isOffspring) {
                    const additionalLifespan = lifespanRange.min / 3;
                    this.lifeSpan += additionalLifespan;
                }

                this.originalSize = this.size;
                this.inSchool = false;
                this.schoolDirection = Math.random() * Math.PI * 2;
                this.schoolChangeTime = Date.now() + Math.random() * 10000;
                this.individualBehavior = Math.random();
                const delayMultiplier = reproductionDelayMultiplier[this.type] || 1;
                this.reproductiveAge = Date.now() + (80000 + Math.random() * 20000) * delayMultiplier;
                this.lastReproduction = 0;
                this.isOffspring = isOffspring;
                this.isAdult = !isOffspring;
                this.lastGrowthTime = Date.now();
                this.verticalMovementScale = 5;
                
                // If offspring, start small
                if (isOffspring) {
                    const smallFishTypes = ["minnow", "perch", "crappie", "guppy", "tetra", "goldfish",  "bluegill", "zebra", "herring"];
                    const sizeFactor = smallFishTypes.includes(type) ? 0.4 : 0.3;

                    this.size = fishSpecies[type].minSize * sizeFactor; // Scale size based on type
                    this.originalSize = this.size; // Set original size
                    this.hunger = 60; // Give offspring a bit more initial hunger
                }
                this.isFoodPresent = false;
                this.causeOfDeath = null;
                // Add initial diving behavior
                this.initialDiveTime = Date.now() + 2000 + Math.random() * 1000;
                this.isDiving = !isOffspring && !isInitial == true;
                // Enhance bottom dwelling behavior
                this.preferredDepth = this.getPreferredDepth();
                this.depthAdjustmentRate = type === 'sturgeon' || type === 'catfish' ? 0.2 : 0.1;
            }
            getAvailableVariants(type) {
                // Get all living adult fish of the same type
                const adultFish = fishArray.filter(f => 
                    f.type === type && 
                    f.isAlive && 
                    f.isAdult
                );

                // Get unique variants present in the tank
                const uniqueVariants = new Set();
                adultFish.forEach(fish => {
                    uniqueVariants.add(fish.variant);
                });

                // If no variants found (shouldn't happen), fallback to all variants
                if (uniqueVariants.size === 0) {
                    return fishSpecies[type].variants;
                }

                return Array.from(uniqueVariants);
            }
            checkHunger() {
                this.hunger -= this.hungerRate;
                if (this.hunger < 0) {
                    this.hunger = 0;
                }
                if (this.hunger === 0) {
                    this.isAlive = false;
                    this.causeOfDeath = 'starvation';
                }
            }
            canEatMore() {
                return this.hunger < 75;
            }
            checkReproduction() {
                if (!this.isAlive || this.fleeingFrom) return;

                if (!this.isAdult || this.size < fishSpecies[this.type].minSize) return;

                const now = Date.now();

                const baseReproductionCooldown = 120000;
                const cooldown = baseReproductionCooldown * (reproductionDelayMultiplier[this.type] || 1);

                const minSize = fishSpecies[this.type].minSize;
                if (minSize >= 25) {
                    const sizePenalty = 1 + (minSize - 25) / 50;
                    const baseThreshold = 1500;
                    const populationThreshold = Math.floor((1 / minSize) * baseThreshold / sizePenalty);
                    const currentPopulation = fishArray.filter(f => f.type === this.type && f.isAlive).length;
                    if (currentPopulation >= populationThreshold) {
                        return;
                    }
                }

                if (now > this.reproductiveAge && now - this.lastReproduction > cooldown) {
                    const mates = fishArray.filter(f => 
                        f.type === this.type &&
                        f !== this &&
                        f.isAlive &&
                        f.isAdult &&
                        f.size >= fishSpecies[this.type].minSize &&
                        now > f.reproductiveAge &&
                        this.distanceTo(f) < this.size * 3
                    );

                    if (mates.length > 0) {
                        const baseOffspring = Math.random() < 0.05 ? 1 : 2;
                        const bonusOffspring = ["guppy", "goldfish", "minnow","tetra","bluegill", "zebra"].includes(this.type) ? Math.floor(Math.random() * 2) : 0;
                        const offspringCount = baseOffspring + bonusOffspring;

                        for (let i = 0; i < offspringCount; i++) {
                            // Pass parent's variant for offspring
                            const offspring = new Fish(this.type, false, true, this.variant);
                            offspring.x = this.x + (Math.random() - 0.5) * this.size;
                            offspring.y = this.y + (Math.random() - 0.5) * this.size;
                            fishArray.push(offspring);
                        }

                        this.lastReproduction = now;
                        updateFishCount();
                    }
                }
            }

            getRandomSize() {
                const species = fishSpecies[this.type];
                return Math.random() * (species.maxSize - species.minSize) + species.minSize;
            }

            reset() {
                if (this.isInitial) {
                    // Initial fish start within bounds
                    this.x = Math.random() * (canvas.width - 100) + 50;
                    this.y = Math.random() * (canvas.height - 100) + 50;
                } else {
                    // New fish only enter from top
                    this.x = Math.random() * canvas.width;
                    this.y = -this.size;
                }
                
                // Face the direction of movement
                this.angle = Math.random() < 0.5 ? 0 : Math.PI; // 0 for right, PI for left
                this.targetAngle = this.angle;
                this.speed = this.baseSpeed * globalSpeedMultiplier;
            }
            
            canEat(prey) {
                // Avoid eating the same species unless hunger-driven
                if (this.type === prey.type && this.hunger >= 20) {
                    return false; // Don't eat its own species unless very hungry
                }

                const isPredator = this.behavior.isPredator;
                const preyIsPredator = prey.behavior.isPredator;

                // Adjust for sturgeon and beluga-specific behavior
                const isLargePredator = this.type === 'sturgeon' || this.type === 'beluga';

                // Traditional predator-prey relationship
                const isPredatorPreyMatch = isPredator &&
                                            this.behavior.preyTypes.includes(prey.type) &&
                                            this.size >= prey.size * (isLargePredator ? 4 : 1.5);

                // Predators eating smaller predators (not the same species)
                const isPredatorEatingSmallPredator = isPredator &&
                                                    preyIsPredator &&
                                                    this.type !== prey.type &&
                                                    this.size >= prey.size * (isLargePredator ? 4 : 2.5);

                // Hunger-driven opportunistic predation
                const isHungerDriven = this.hunger < 20 &&
                                    (isPredator
                                            ? prey.size <= this.size * (isLargePredator ? 0.3 : 0.45)
                                            : prey.size <= this.size * 0.2);

                return isPredatorPreyMatch || isPredatorEatingSmallPredator || isHungerDriven;
            }

            updateSchooling() {
                if (this.behavior.isSchooling) {
                    // Find nearby fish of same type within school range
                    const schoolmates = fishArray.filter(f => 
                        f.type === this.type && 
                        f !== this && 
                        f.isAlive &&
                        this.distanceTo(f) < 150
                    );

                    // Get all nearby fish for collision avoidance
                    const nearbyFish = fishArray.filter(f => 
                        f !== this && 
                        f.isAlive &&
                        this.distanceTo(f) < (this.size + f.size) * 1.5
                    );

                    // Update school membership
                    if (schoolmates.length > 0) {
                        if (!this.inSchool && this.individualBehavior > 0.3) {
                            this.inSchool = true;
                        } else if (this.inSchool && this.individualBehavior < 0.2) {
                            this.inSchool = false;
                        }
                    } else {
                        this.inSchool = false;
                    }

                    // Calculate schooling behavior
                    if (this.inSchool && schoolmates.length > 0) {
                        let cohesionX = 0, cohesionY = 0;      // Center of school
                        let alignmentX = 0, alignmentY = 0;     // Average direction
                        let separationX = 0, separationY = 0;   // Keep distance from schoolmates
                        let avoidanceX = 0, avoidanceY = 0;     // Avoid other fish species

                        // Calculate cohesion and alignment
                        schoolmates.forEach(f => {
                            // Cohesion - move toward center of school
                            cohesionX += f.x;
                            cohesionY += f.y;

                            // Alignment - match school's direction
                            const angleVector = {
                                x: Math.cos(f.angle),
                                y: Math.sin(f.angle)
                            };
                            alignmentX += angleVector.x;
                            alignmentY += angleVector.y;

                            // Separation - maintain minimum distance from schoolmates
                            const dist = this.distanceTo(f);
                            const minDist = (this.size + f.size) * 1;
                            if (dist < minDist) {
                                separationX += (this.x - f.x) / (dist || 1) * (minDist - dist);
                                separationY += (this.y - f.y) / (dist || 1) * (minDist - dist);
                            }
                        });

                        // Calculate avoidance of other fish species
                        nearbyFish.forEach(f => {
                            if (f.type !== this.type) {
                                const dist = this.distanceTo(f);
                                const minDist = (this.size + f.size) * 1.2;
                                if (dist < minDist) {
                                    avoidanceX += (this.x - f.x) / (dist || 1);
                                    avoidanceY += (this.y - f.y) / (dist || 1);
                                }
                            }
                        });

                        const schoolCenter = {
                            x: schoolmates.reduce((sum, f) => sum + f.x, 0) / schoolmates.length,
                            y: schoolmates.reduce((sum, f) => sum + f.y, 0) / schoolmates.length
                        };

                        const angleToSchoolCenter = Math.atan2(schoolCenter.y - this.y, schoolCenter.x - this.x);
                        const distanceToSchoolCenter = Math.sqrt(Math.pow(schoolCenter.x - this.x, 2) + Math.pow(schoolCenter.y - this.y, 2));

                        const circularSchoolingStrength = 0.1;
                        const circularSchoolingRadius = Math.min(canvas.width, canvas.height) / 4 + schoolmates.length * 5;

                        let circularSchoolingX = 0;
                        let circularSchoolingY = 0;

                        if (distanceToSchoolCenter > circularSchoolingRadius) {
                            circularSchoolingX = Math.cos(angleToSchoolCenter + Math.PI / 2) * circularSchoolingStrength;
                            circularSchoolingY = Math.sin(angleToSchoolCenter + Math.PI / 2) * circularSchoolingStrength;
                        } else {
                            circularSchoolingX = Math.cos(angleToSchoolCenter - Math.PI / 2) * circularSchoolingStrength;
                            circularSchoolingY = Math.sin(angleToSchoolCenter - Math.PI / 2) * circularSchoolingStrength;
                        }

                        // Complex schooling behavior
                        const schoolingStrength = 0.05;
                        const schoolingTorque = 0.1;

                        const schoolingX = (cohesionX / schoolmates.length - this.x) * schoolingStrength;
                        const schoolingY = (cohesionY / schoolmates.length - this.y) * schoolingStrength;

                        const alignmentStrength = alignmentX * schoolingStrength;
                        const alignmentTorque = alignmentY * schoolingTorque;

                        const separationStrength = separationX * schoolingStrength * 2;
                        const separationTorque = separationY * schoolingTorque * 2;

                        const avoidanceStrength = avoidanceX * schoolingStrength * 3;
                        const avoidanceTorque = avoidanceY * schoolingTorque * 3;

                        // Calculate final target position
                        const targetX = this.x + schoolingX + separationStrength + avoidanceStrength + circularSchoolingX;
                        const targetY = this.y + schoolingY + separationTorque + avoidanceTorque + circularSchoolingY;

                        // Calculate desired angle
                        let desiredAngle = Math.atan2(targetY - this.y, targetX - this.x);
                        if (Math.abs(desiredAngle - this.angle) > Math.PI) {
                            this.angle = desiredAngle;
                        }
                        // Apply alignment torque
                        desiredAngle += alignmentTorque;

                        // Smooth turning
                        let angleDiff = desiredAngle - this.angle;
                        while (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;
                        while (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;

                        // Limit turn rate
                        angleDiff = Math.max(Math.min(angleDiff, Math.PI / 8), -Math.PI / 8);
                        this.targetAngle = this.angle + angleDiff;
                        this.angle = this.lerpAngle(this.angle, this.targetAngle, 0.05);

                        // Adjust speed based on position in school
                        const distToCenter = Math.sqrt(
                            Math.pow(targetX - this.x, 2) +
                            Math.pow(targetY - this.y, 2)
                        );

                        if (distToCenter > this.size * 6) {
                            this.speed = this.baseSpeed * 1.2; // Speed up to catch school
                        } else if (distToCenter < this.size * 2) {
                            this.speed = this.baseSpeed * 0.6; // Slow down if too close
                        } else {
                            this.speed = this.baseSpeed;
                        }
                    } else {
                        // Individual movement when not in school
                        if (Math.random() < 0.02) {
                            this.targetAngle += (Math.random() - 0.5) * Math.PI / 4;
                        }
                    }

                    // Handle boundaries
                    const margin = 0;
                    if (this.x < margin || this.x > canvas.width - margin) {
                        this.schoolDirection = this.x < margin ? 0 : Math.PI;
                        this.targetAngle = this.schoolDirection;
                    }
                }
            }

            updatePredatorBehavior() {
                // Only hunt if hungry enough
                if (this.canEatMore()) {
                    let nearestPrey = null;
                    let minDistance = 220;  // Detection radius

                    fishArray.forEach(f => {
                        if (f.isAlive && this.canEat(f)) {
                            const dist = this.distanceTo(f);
                            if (dist < minDistance) {
                                minDistance = dist;
                                nearestPrey = f;
                            }
                        }
                    });

                    if (nearestPrey) {
                        if (minDistance < this.size / 2) {
                            nearestPrey.causeOfDeath = 'eaten';
                            nearestPrey.isAlive = false;

                            // Immediately remove eaten fish
                            const index = fishArray.indexOf(nearestPrey);
                            if (index > -1) {
                                fishArray.splice(index, 1);
                                updateFishCount(); // Update the count
                            }

                            // Adjust size and hunger gain based on prey size
                            if (nearestPrey.size > this.size * 0.4) {
                                this.size = Math.min(this.size + 5 + Math.random() * 3, fishSpecies[this.type].maxSize); // Larger prey
                                this.hunger = Math.min(this.hunger + 32, 100);
                            } else if (nearestPrey.size > this.size * 0.2) {
                                this.size = Math.min(this.size + 3 + Math.random() * 2, fishSpecies[this.type].maxSize); // Medium prey
                                this.hunger = Math.min(this.hunger + 16, 100);
                            } else {
                                this.size = Math.min(this.size + 1 + Math.random() * 1, fishSpecies[this.type].maxSize); // Smaller prey
                                this.hunger = Math.min(this.hunger + 8, 100);
                            }

                            this.lastMealTime = Date.now();
                            return;
                        }
                        // Adjust speed based on distance
                        if (minDistance < 80) {
                            this.speed = this.baseSpeed * 2.5; // Final sprint
                        } else if (minDistance < 160) {
                            this.speed = this.baseSpeed * 2; // Chase speed
                        } else {
                            this.speed = this.baseSpeed * 1.5; // Approach speed
                        }
                        // Chase behavior
                        const angleToTarget = Math.atan2(
                            nearestPrey.y - this.y,
                            nearestPrey.x - this.x
                        );
                        if (Math.abs(angleToTarget - this.angle) > Math.PI) {
                            this.angle = angleToTarget;
                        }
                        // Adjust angle based on prediction of prey movement
                        if (nearestPrey.fleeingFrom === this) {
                            const predictionFactor = 1.5;
                            const predictedX = nearestPrey.x + Math.cos(nearestPrey.angle) * nearestPrey.speed * predictionFactor;
                            const predictedY = nearestPrey.y + Math.sin(nearestPrey.angle) * nearestPrey.speed * predictionFactor;
                            this.targetAngle = Math.atan2(predictedY - this.y, predictedX - this.x);
                        } else {
                            this.targetAngle = angleToTarget;
                        }

                        // Smooth turning
                        this.angle = this.lerpAngle(this.angle, this.targetAngle, 0.05);

                        // Mark prey as being chased
                        nearestPrey.fleeingFrom = this;
                    } else {
                        // Return to normal speed when not chasing
                        this.speed = this.baseSpeed;
                    }
                } else {
                    // Not hungry enough to hunt
                    this.speed = this.baseSpeed;
                }
            }

            updatePreyBehavior() {
                if (this.fleeingFrom) {
                    // Flee from predator
                    const angleAway = Math.atan2(
                        this.y - this.fleeingFrom.y,
                        this.x - this.fleeingFrom.x
                    );
                    if (Math.abs(angleAway - this.angle) > Math.PI) {
                        this.angle = angleAway;
                    }
                    this.targetAngle = angleAway;
                    this.angle = this.lerpAngle(this.angle, this.targetAngle, 0.15);
                    this.speed = this.baseSpeed * 1.3; // Flee faster
                    
                    if (this.distanceTo(this.fleeingFrom) > 150) {
                        this.fleeingFrom = null;
                    }
                } else {
                    this.speed = this.baseSpeed;
                }
            }

            checkForFood() {
                if (this.isAlive && this.canEatMore()) {
                    for (let pellet of foodPellets) {
                        if (!pellet.consumed) {
                            const dist = Math.sqrt(
                                Math.pow(this.x - pellet.x, 2) +
                                Math.pow(this.y - pellet.y, 2)
                            );

                            if (dist < 100) { // Detection radius
                                // Move towards food
                                const angleToFood = Math.atan2(pellet.y - this.y, pellet.x - this.x);
                                this.targetAngle = angleToFood;
                                this.speed = this.baseSpeed * 1.5; // Increased speed when chasing food

                                if (dist < this.size / 2) {
                                    pellet.consumed = true;
                                    this.grow();
                                    this.lastMealTime = Date.now();
                                    this.hunger = Math.min(this.hunger + 15, 100);
                                }
                                return true;
                            }
                        }
                    }
                    return false;
                } else {
                    return false;
                }
            }
            distanceTo(other) {
                const dx = other.x - this.x;
                const dy = other.y - this.y;
                return Math.sqrt(dx * dx + dy * dy);
            }

            lerpAngle(a, b, t) {
                const diff = b - a;
                return a + diff * t;
            }
            getPreferredDepth() {
                const preference = fishSpecies[this.type].depthPreference;
                const margin = 100;
                
                switch(preference) {
                    case 'bottom':
                        return canvas.height - margin - Math.random() * 100;
                    case 'top':
                        return margin + Math.random() * 100;
                    default: // 'middle'
                        return canvas.height/2 + (Math.random() - 0.5) * 200;
                }
            }
            checkSpook() {
                if (!spookCenter) return;
                
                const timeSinceSpook = Date.now() - spookStartTime;
                if (timeSinceSpook > spookDuration) {
                    spookCenter = null;
                    return;
                }

                const distToSpook = Math.sqrt(
                    Math.pow(this.x - spookCenter.x, 2) + 
                    Math.pow(this.y - spookCenter.y, 2)
                );

                if (distToSpook < spookRadius) {
                    // Calculate angle away from spook point
                    const angleAway = Math.atan2(
                        this.y - spookCenter.y,
                        this.x - spookCenter.x
                    );
                    
                    // Stronger reaction for closer fish
                    const intensityFactor = 1 - (distToSpook / spookRadius);
                    this.speed = this.baseSpeed * (2 + intensityFactor * 2);
                    
                    // Turn away from spook point
                    this.targetAngle = angleAway;
                    this.angle = this.lerpAngle(this.angle, this.targetAngle, 0.3);
                    
                    // Break from schooling temporarily
                    this.inSchool = false;
                }
            }
            move() {
                if (!this.isAlive) {
                    if (this.causeOfDeath === 'starvation') {
                        this.rotationForDeath = Math.min(this.rotationForDeath + 0.05, Math.PI);
                        this.opacity = Math.max(0, this.opacity - 0.02);

                        if (this.opacity <= 0) {
                            const index = fishArray.indexOf(this);
                            if (index > -1) {
                                fishArray.splice(index, 1);
                            }
                        }
                    } else if (this.causeOfDeath === 'natural' || this.causeOfDeath === 'random') {
                        this.rotationForDeath = Math.min(this.rotationForDeath + 0.05, Math.PI);
                        this.opacity = Math.max(0, this.opacity - 0.02);

                        if (this.opacity <= 0) {
                            const index = fishArray.indexOf(this);
                            if (index > -1) {
                                fishArray.splice(index, 1);
                            }
                        }
                    }
                    return;
                }
                // Ensure minimum speed to avoid freezing
                if (this.speed < 0.1) {
                    this.speed = this.baseSpeed * 0.5; // Set a fallback speed
                }
                if (this.isDiving && Date.now() < this.initialDiveTime) {
                    const targetDepth = canvas.height * 1.5;
                    if (this.y < targetDepth) {
                        this.y += this.speed * 0.8;
                    }
                    return;
                }
                this.isDiving = false;
                this.checkHunger();
                this.checkReproduction();

                const foodExists = foodPellets.length > 0;
                let isChasing = false;

                if (foodExists && this.canEatMore()) {
                    // Food chasing logic
                    let nearestFood = null;
                    let minDistance = Infinity;

                    for (let pellet of foodPellets) {
                        if (!pellet.consumed) {
                            const dist = this.distanceTo(pellet);
                            if (dist < minDistance) {
                                minDistance = dist;
                                nearestFood = pellet;
                            }
                        }
                    }
                    if (this.canEatMore() && this.updatePredatorBehavior()) {
                        return; // Predator behavior takes precedence
                    }
                    if (nearestFood) {
                        // Move towards nearest food
                        const angleToFood = Math.atan2(
                            nearestFood.y - this.y,
                            nearestFood.x - this.x
                        );
                        this.targetAngle = angleToFood;
                        this.angle = this.lerpAngle(this.angle, this.targetAngle, 0.1);

                        if (minDistance < this.size / 2) {
                            nearestFood.consumed = true;
                            this.grow();
                            this.lastMealTime = Date.now();
                            this.hunger = Math.min(this.hunger + 20, 100);
                        }

                        // Move faster towards food if close
                        this.speed = minDistance < 180 ? this.baseSpeed * 1.8 : this.baseSpeed;
                    }
                } else {
                    this.updateSchooling();
                    if (this.behavior.isPredator) {
                        this.updatePredatorBehavior();
                    }
                    this.updatePreyBehavior();

                    // Apply depth preferences more strongly for bottom dwellers
                    if (fishSpecies[this.type].depthPreference === 'bottom') {
                        const targetDepth = canvas.height * 0.85;
                        const depthDiff = targetDepth - this.y;

                        if (depthDiff > 0) {
                            // Gradually move towards preferred depth
                            this.y += depthDiff * this.depthAdjustmentRate * 0.02;
                        }

                        // Reduce vertical movement for bottom dwellers
                        this.verticalMovementScale = 1;
                    } else {
                        // Random vertical movement for other fish
                        if (!this.fleeingFrom && Math.random() < 0.02) {
                            this.y += (Math.random() - 0.5) * this.verticalMovementScale;
                        }
                    }

                    if (fishSpecies[this.type].depthPreference === 'top') {
                        // Only apply gentle top tendency when not chasing food/escaping
                        if (!this.fleeingFrom && !this.chasingFood) {
                            const topTarget = canvas.height * 0.3; // Prefer upper 30% of tank
                            if (this.y > topTarget && Math.random() < 0.05) { // Gentle upward tendency
                                this.y -= this.speed * 0.2; // Gentle upward drift
                            }

                            // Allow occasional downward exploration
                            if (Math.random() < 0.02) {
                                this.y += this.speed * 0.1; 
                            }

                            // Prevent staying too close to surface
                            if (this.y < canvas.height * 0.1) { // Too close to surface
                                this.y += this.speed * 0.05; // Gentle push down
                            }
                        }
                    }
                }

                if (!this.fleeingFrom && !this.chasingFood) {
                    if (Math.random() < 0.005) {
                        // If currently moving left, switch to right and vice versa
                        if (Math.abs(this.angle) > Math.PI / 2) {
                            this.targetAngle = 0;  // Switch to moving right
                        } else {
                            this.targetAngle = Math.PI;  // Switch to moving left
                        }
                    }

                    // Smooth turn towards target angle
                    if (this.targetAngle !== this.angle) {
                        const turnSpeed = 0.02;
                        let angleDiff = this.targetAngle - this.angle;

                        // Normalize angle difference
                        while (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;
                        while (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;

                        this.angle += angleDiff * turnSpeed;
                    }

                    // Occasionally make small adjustments to vertical position
                    if (Math.random() < 0.01) { // 1% chance each frame
                        this.y += (Math.random() - 0.5) * 2; // Small vertical adjustment
                    }
                }

                // Adding Buoyancy to Help Offset Sinking
                const buoyancyForce = 0.05;  // Adjust this value for desired upward effect
                this.y -= buoyancyForce;

                this.checkSpook();
                // Update Position and Handle Boundaries More Aggressively
                this.x += Math.cos(this.angle) * this.speed;
                this.y += Math.sin(this.angle) * this.speed * 0.7;

                const margin = 20;
                const bottomMargin = 50;

                // Enhanced Boundary Handling to Prevent Stacking at Corners
                if (this.x < margin) {
                    this.x = margin;
                    this.targetAngle = Math.random() * Math.PI / 2; // Turn towards the right
                    this.angle = this.targetAngle;
                } else if (this.x > canvas.width - margin) {
                    this.x = canvas.width - margin;
                    this.targetAngle = Math.PI + Math.random() * Math.PI / 2; // Turn towards the left
                    this.angle = this.targetAngle;
                }

                if (this.y < margin) {
                    this.y = margin;
                    this.targetAngle = Math.PI / 2 + Math.random() * Math.PI / 2; // Turn downwards
                    this.angle = this.targetAngle;
                } else if (this.y > canvas.height - bottomMargin) {
                    this.y = canvas.height - bottomMargin;
                    if (!this.isAlive) {
                        // If fish is dead, apply natural sinking behavior
                        this.targetAngle = Math.PI; // Set angle for a downward movement if necessary
                    } else if (this.canEatMore() || this.fleeingFrom) {
                        // If the fish is hungry or fleeing, ensure an aggressive turn upwards to move away from the bottom
                        this.targetAngle = -Math.PI / 2 + Math.random() * Math.PI / 2; // Turn upwards
                    } else {
                        // For fish that are not fleeing or hungry, gently encourage them to turn upwards
                        this.targetAngle = -Math.PI / 3 + Math.random() * Math.PI / 3; // More subtle turn upwards
                    }
                    this.angle = this.lerpAngle(this.angle, this.targetAngle, 0.1); // Smoothly change direction upwards
                }
            }

            grow() {
                const currentTime = Date.now();
                if (currentTime - this.lastGrowthTime < 1000) {
                    return;
                }
                this.lastGrowthTime = currentTime;

                const speciesMaxSize = fishSpecies[this.type].maxSize;
                const speciesMinSize = fishSpecies[this.type].minSize;
                // Calculate species size range to determine growth rate
                const sizeRange = speciesMinSize;
                const growthMultiplier = sizeRange / 30; // Base multiplier on size range
                
                if (!this.isAdult) {
                    // Juvenile growth
                    const baseGrowthRate = 3 + Math.random() * 2;
                    const growthAmount = baseGrowthRate * growthMultiplier;
                    this.size = Math.min(this.size + growthAmount, speciesMinSize);
                    
                    // Check if reached adult size
                    if (this.size >= speciesMinSize) {
                        this.isAdult = true;
                        const minLifespan = fishLifeSpans[this.type].min;
                        const bonusLifespan = minLifespan * 0.3;
                        this.lifeSpan += bonusLifespan;
                    }
                } else {
                    // Adult growth
                    const baseGrowthRate = 2 + Math.random() * 1;
                    const growthAmount = baseGrowthRate * growthMultiplier;
                    this.size = Math.min(this.size + growthAmount, speciesMaxSize);
                }
            }
            checkLifespan() {
                const age = Date.now() - this.birthTime;
                const timeSinceLastMeal = Date.now() - this.lastMealTime;
                
                if (age > this.lifeSpan || timeSinceLastMeal > this.lifeSpan / 2) {
                    this.isAlive = false;
                    this.causeOfDeath = 'natural';
                }
            }
            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                
                if (!this.isAlive) {
                    ctx.rotate(this.rotationForDeath);
                    ctx.globalAlpha = this.opacity;
                }

                const movingLeft = Math.abs(this.angle) > Math.PI/2;

                ctx.scale(-1, 1);

                if (movingLeft) {
                    ctx.scale(-1, 1);
                }

                const imageKey = (this.variant && (this.type === 'goldfish' || this.type === 'koi'|| this.type === 'ghost')) 
                    ? this.variant 
                    : this.type;

                ctx.drawImage(
                    fishImages[imageKey],
                    -this.size/2,
                    -this.size/2,
                    this.size,
                    this.size
                );
                ctx.restore();
            }
        }

        let isDarkMode = true; // Start with dark mode by default

        let surfaceLights = [];
        const LIGHT_COUNT = 10;

        function initializeSurfaceLights() {
            surfaceLights = [];
            for (let i = 0; i < LIGHT_COUNT; i++) {
                surfaceLights.push({
                    x: Math.random() * canvas.width,
                    intensity: 0.2 + Math.random() * 0.4,
                    speed: 0.1 + Math.random() * 0.2,
                    width: 100 + Math.random() * 200
                });
            }
        }
        function animateBackground() {
            drawNaturalBackground();
        }
        function drawNaturalBackground() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            if (isDarkMode) {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            } else {
                // Enhanced gradient for water - darker at bottom
                let gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
                gradient.addColorStop(0, 'rgba(0, 75, 65, 0.9)');     // Dark green at top
                gradient.addColorStop(0.5, 'rgba(0, 45, 40, 0.95)');  // Darker middle
                gradient.addColorStop(1, 'rgba(0, 25, 20, 0.98)');    // Even darker bottom
                
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // Draw surface light effects
                surfaceLights.forEach(light => {
                    // Update light position
                    light.x += light.speed;
                    if (light.x > canvas.width + light.width) {
                        light.x = -light.width;
                    }

                    let beamGradient = ctx.createRadialGradient(
                        light.x, 0, 0,
                        light.x, 0, light.width
                    );
                    
                    beamGradient.addColorStop(0, `rgba(255, 250, 240, ${light.intensity * 0.2})`);
                    beamGradient.addColorStop(0.5, `rgba(240, 240, 230, ${light.intensity * 0.1})`);
                    beamGradient.addColorStop(1, 'rgba(255, 255, 255, 0)');

                    ctx.fillStyle = beamGradient;
                    
                    ctx.beginPath();
                    ctx.moveTo(light.x - light.width/2, 0);
                    ctx.lineTo(light.x + light.width/2, 0);
                    ctx.lineTo(light.x + light.width, canvas.height);
                    ctx.lineTo(light.x - light.width, canvas.height);
                    ctx.closePath();
                    ctx.fill();
                });
            }
        }

        function updateBackground() {
            if (fishArray.length === 0) {
                // If no fish, just draw the background once
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                if (!isDarkMode) {
                    let gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
                    gradient.addColorStop(0, 'rgba(0, 75, 65, 0.9)');
                    gradient.addColorStop(0.5, 'rgba(0, 45, 40, 0.95)');
                    gradient.addColorStop(1, 'rgba(0, 25, 20, 0.98)');
                    
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                } else {
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                }
            }
        }

        function toggleDayNight() {
            isDarkMode = !isDarkMode;
            
            if (!isDarkMode) {
                // Always initialize surface lights when switching to day mode if they don't exist
                if (surfaceLights.length === 0) {
                    initializeSurfaceLights();
                }

                // Start animating surface lights even without fish
                function animateSurfaceLights() {
                    if (!isDarkMode) {  // Keep animating as long as in day mode
                        ctx.clearRect(0, 0, canvas.width, canvas.height);
                        
                        // Draw gradient background
                        let gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
                        gradient.addColorStop(0, 'rgba(0, 75, 65, 0.9)');
                        gradient.addColorStop(0.5, 'rgba(0, 45, 40, 0.95)');
                        gradient.addColorStop(1, 'rgba(0, 25, 20, 0.98)');
                        
                        ctx.fillStyle = gradient;
                        ctx.fillRect(0, 0, canvas.width, canvas.height);
                        
                        // Animate surface lights
                        surfaceLights.forEach(light => {
                            light.x += light.speed;
                            if (light.x > canvas.width + light.width) {
                                light.x = -light.width;
                            }

                            let beamGradient = ctx.createRadialGradient(
                                light.x, 0, 0,
                                light.x, 0, light.width
                            );
                            
                            beamGradient.addColorStop(0, `rgba(255, 250, 240, ${light.intensity * 0.2})`);
                            beamGradient.addColorStop(0.5, `rgba(240, 240, 230, ${light.intensity * 0.1})`);
                            beamGradient.addColorStop(1, 'rgba(255, 255, 255, 0)');

                            ctx.fillStyle = beamGradient;
                            
                            ctx.beginPath();
                            ctx.moveTo(light.x - light.width/2, 0);
                            ctx.lineTo(light.x + light.width/2, 0);
                            ctx.lineTo(light.x + light.width, canvas.height);
                            ctx.lineTo(light.x - light.width, canvas.height);
                            ctx.closePath();
                            ctx.fill();
                        });
                        
                        requestAnimationFrame(animateSurfaceLights);
                    }
                }

                // Start the animation if there are no fish
                if (!fishActive) {
                    animateSurfaceLights();
                }
            }
            
            const toggleButton = document.querySelector('.control-button[onclick="toggleDayNight()"]');
            toggleButton.innerHTML = isDarkMode ? "Mode: 🌙" : "Mode: 🌞";
            
            const overlay = document.createElement('div');
            overlay.style.position = 'fixed';
            overlay.style.top = '0';
            overlay.style.left = '0';
            overlay.style.width = '100%';
            overlay.style.height = '100%';
            overlay.style.backgroundColor = isDarkMode ? 'rgba(0, 0, 0, 0.5)' : 'rgba(0, 75, 65, 0.5)';
            overlay.style.transition = 'opacity 2s';
            overlay.style.pointerEvents = 'none';
            overlay.style.zIndex = '1';
            document.body.appendChild(overlay);

            setTimeout(() => {
                overlay.style.opacity = '0';
                setTimeout(() => {
                    overlay.remove();
                }, 2000);
            }, 100);

            updateBackground();

            if (fishArray.length > 0) {
                const speedMultiplier = isDarkMode ? 0.9 : 1;
                fishArray.forEach(fish => {
                    fish.speed = fish.baseSpeed * speedMultiplier;
                });
            }
        }

        function drawFish() {
            // Clear canvas first
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw appropriate background first
            if (!isDarkMode) {
                // Draw day mode background without light effects
                let gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
                gradient.addColorStop(0, 'rgba(0, 75, 65, 0.9)');     // Dark green at top
                gradient.addColorStop(0.5, 'rgba(0, 45, 40, 0.95)');  // Darker middle
                gradient.addColorStop(1, 'rgba(0, 25, 20, 0.98)');    // Even darker bottom
                
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // Draw light effects
                surfaceLights.forEach(light => {
                    // Only update positions if animation is active
                    if (animationActive) {
                        light.x += light.speed;
                        if (light.x > canvas.width + light.width) {
                            light.x = -light.width;
                        }
                    }

                    let beamGradient = ctx.createRadialGradient(
                        light.x, 0, 0,
                        light.x, 0, light.width
                    );
                    
                    beamGradient.addColorStop(0, `rgba(255, 250, 240, ${light.intensity * 0.2})`);
                    beamGradient.addColorStop(0.5, `rgba(240, 240, 230, ${light.intensity * 0.1})`);
                    beamGradient.addColorStop(1, 'rgba(255, 255, 255, 0)');

                    ctx.fillStyle = beamGradient;
                    
                    ctx.beginPath();
                    ctx.moveTo(light.x - light.width/2, 0);
                    ctx.lineTo(light.x + light.width/2, 0);
                    ctx.lineTo(light.x + light.width, canvas.height);
                    ctx.lineTo(light.x - light.width, canvas.height);
                    ctx.closePath();
                    ctx.fill();
                });
            } else {
                // Dark mode background
                ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }

            // Draw food pellets
            for (let i = foodPellets.length - 1; i >= 0; i--) {
                const pellet = foodPellets[i];
                if (animationActive) {
                    if (!pellet.update()) {
                        foodPellets.splice(i, 1);
                        continue;
                    }
                }
                pellet.draw();
            }

            // Draw fish on top
            if (fishArray.length > 0) {
                for (let i = fishArray.length - 1; i >= 0; i--) {
                    const fish = fishArray[i];
                    if (animationActive) {
                        fish.checkLifespan();
                        fish.move();
                    }
                    fish.draw();

                    if (!fish.isAlive && fish.opacity <= 0) {
                        removeFish(fish);
                    }
                }
            }

            // If not actively animating but we have fish, request another frame
            if (!animationActive && fishArray.length > 0) {
                requestAnimationFrame(drawFish);
            }
        }
        function animate() {
            if (!animationActive) return;
            
            updateAttractor();
            drawFish();
            animationFrameId = requestAnimationFrame(animate);
        }
        function stopAnimation() {
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }

            animationActive = false;

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        }
        function toggleAnimation() {
            animationActive = !animationActive;
            const toggleButton = document.querySelector('.control-button[onclick="toggleAnimation()"]');
            
            if (animationActive) {
                toggleButton.textContent = "Playing";
                animate();
            } else {
                toggleButton.textContent = "Paused";
                // Keep drawing frames even when paused
                if (fishArray.length > 0) {
                    drawFish();
                }
            }
        }

        window.addEventListener("resize", () => {
            initializeSurfaceLights();
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        });
    </script>
</body>
</html>